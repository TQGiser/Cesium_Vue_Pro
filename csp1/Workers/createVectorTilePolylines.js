define(["./Matrix2-fc7e9822","./combine-761d9c3f","./AttributeCompression-4d18cc04","./ComponentDatatype-4a60b8d6","./IndexDatatype-db156785","./createTaskProcessorWorker","./RuntimeError-c581ca93","./defaultValue-94c3e563","./WebGLConstants-7dccdc96"],(function(e,t,a,n,r,s,i,o,c){"use strict";const u=32767,f=new e.Cartographic,d=new e.Cartesian3;function p(t,r,s,i,o){const c=t.length/3,p=t.subarray(0,c),l=t.subarray(c,2*c),C=t.subarray(2*c,3*c);a.AttributeCompression.zigZagDeltaDecode(p,l,C);const b=new Float64Array(t.length);for(let a=0;a<c;++a){const t=p[a],c=l[a],w=C[a],y=n.CesiumMath.lerp(r.west,r.east,t/u),h=n.CesiumMath.lerp(r.south,r.north,c/u),k=n.CesiumMath.lerp(s,i,w/u),m=e.Cartographic.fromRadians(y,h,k,f),A=o.cartographicToCartesian(m,d);e.Cartesian3.pack(A,b,3*a)}return b}const l=new e.Rectangle,C=new e.Ellipsoid,b=new e.Cartesian3,w={min:void 0,max:void 0};function y(t){t=new Float64Array(t);let a=0;w.min=t[a++],w.max=t[a++],e.Rectangle.unpack(t,a,l),a+=e.Rectangle.packedLength,e.Ellipsoid.unpack(t,a,C),a+=e.Ellipsoid.packedLength,e.Cartesian3.unpack(t,a,b)}function h(e){const t=e.length,a=new Uint32Array(t+1);let n=0;for(let r=0;r<t;++r)a[r]=n,n+=e[r];return a[t]=n,a}const k=new e.Cartesian3,m=new e.Cartesian3,A=new e.Cartesian3,g=new e.Cartesian3,x=new e.Cartesian3;function D(a,n){const s=new Uint16Array(a.positions),i=new Uint16Array(a.widths),o=new Uint32Array(a.counts),c=new Uint16Array(a.batchIds);y(a.packedBuffer);const u=l,f=C,d=b,D=w.min,E=w.max,I=p(s,u,D,E,f),P=I.length/3,U=4*P-4,R=new Float32Array(3*U),T=new Float32Array(3*U),F=new Float32Array(3*U),N=new Float32Array(2*U),M=new Uint16Array(U);let v,L=0,S=0,_=0,G=0,W=o.length;for(v=0;v<W;++v){const t=o[v],a=i[v],n=c[v];for(let r=0;r<t;++r){let s;if(0===r){const t=e.Cartesian3.unpack(I,3*G,k),a=e.Cartesian3.unpack(I,3*(G+1),m);s=e.Cartesian3.subtract(t,a,A),e.Cartesian3.add(t,s,s)}else s=e.Cartesian3.unpack(I,3*(G+r-1),A);const i=e.Cartesian3.unpack(I,3*(G+r),g);let o;if(r===t-1){const a=e.Cartesian3.unpack(I,3*(G+t-1),k),n=e.Cartesian3.unpack(I,3*(G+t-2),m);o=e.Cartesian3.subtract(a,n,x),e.Cartesian3.add(a,o,o)}else o=e.Cartesian3.unpack(I,3*(G+r+1),x);e.Cartesian3.subtract(s,d,s),e.Cartesian3.subtract(i,d,i),e.Cartesian3.subtract(o,d,o);const c=0===r?2:0,u=r===t-1?2:4;for(let t=c;t<u;++t){e.Cartesian3.pack(i,R,L),e.Cartesian3.pack(s,T,L),e.Cartesian3.pack(o,F,L),L+=3;const r=t-2<0?-1:1;N[S++]=t%2*2-1,N[S++]=r*a,M[_++]=n}}G+=t}const B=r.IndexDatatype.createTypedArray(U,6*P-6);let O=0,z=0;for(W=P-1,v=0;v<W;++v)B[z++]=O,B[z++]=O+2,B[z++]=O+1,B[z++]=O+1,B[z++]=O+2,B[z++]=O+3,O+=4;n.push(R.buffer,T.buffer,F.buffer),n.push(N.buffer,M.buffer,B.buffer);let H={indexDatatype:2===B.BYTES_PER_ELEMENT?r.IndexDatatype.UNSIGNED_SHORT:r.IndexDatatype.UNSIGNED_INT,currentPositions:R.buffer,previousPositions:T.buffer,nextPositions:F.buffer,expandAndWidth:N.buffer,batchIds:M.buffer,indices:B.buffer};if(a.keepDecodedPositions){const e=h(o);n.push(I.buffer,e.buffer),H=t.combine(H,{decodedPositions:I.buffer,decodedPositionOffsets:e.buffer})}return H}var E=s(D);return E}));