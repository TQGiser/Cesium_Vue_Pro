define(["exports","./Matrix2-fc7e9822","./PolylineVolumeGeometryLibrary-759a8d46","./defaultValue-94c3e563","./ComponentDatatype-4a60b8d6","./PolylinePipeline-7608e667","./Transforms-a076dbe6"],(function(a,e,n,t,r,i,s){"use strict";const o={},l=new e.Cartesian3,C=new e.Cartesian3,c=new e.Cartesian3,y=new e.Cartesian3,u=[new e.Cartesian3,new e.Cartesian3],d=new e.Cartesian3,p=new e.Cartesian3,m=new e.Cartesian3,g=new e.Cartesian3,f=new e.Cartesian3,h=new e.Cartesian3,w=new e.Cartesian3,x=new e.Cartesian3,z=new e.Cartesian3,P=new e.Cartesian3,A=new s.Quaternion,B=new e.Matrix3;function E(a,t,i,o,c){const y=e.Cartesian3.angleBetween(e.Cartesian3.subtract(t,a,l),e.Cartesian3.subtract(i,a,C)),u=o===n.CornerType.BEVELED?1:Math.ceil(y/r.CesiumMath.toRadians(5))+1,d=3*u,p=new Array(d);let m;p[d-3]=i.x,p[d-2]=i.y,p[d-1]=i.z,m=c?e.Matrix3.fromQuaternion(s.Quaternion.fromAxisAngle(e.Cartesian3.negate(a,l),y/u,A),B):e.Matrix3.fromQuaternion(s.Quaternion.fromAxisAngle(a,y/u,A),B);let g=0;t=e.Cartesian3.clone(t,l);for(let n=0;n<u;n++)t=e.Matrix3.multiplyByVector(m,t,t),p[g++]=t.x,p[g++]=t.y,p[g++]=t.z;return p}function S(a){let t=d,r=p,i=m,s=a[1];r=e.Cartesian3.fromArray(a[1],s.length-3,r),i=e.Cartesian3.fromArray(a[0],0,i),t=e.Cartesian3.midpoint(r,i,t);const o=E(t,r,i,n.CornerType.ROUNDED,!1),l=a.length-1,C=a[l-1];s=a[l],r=e.Cartesian3.fromArray(C,C.length-3,r),i=e.Cartesian3.fromArray(s,0,i),t=e.Cartesian3.midpoint(r,i,t);const c=E(t,r,i,n.CornerType.ROUNDED,!1);return[o,c]}function b(a,n,t,r){let i=l;return r||(n=e.Cartesian3.negate(n,n)),i=e.Cartesian3.add(a,n,i),[i.x,i.y,i.z,t.x,t.y,t.z]}function D(a,n,t,r){const i=new Array(a.length),s=new Array(a.length),o=e.Cartesian3.multiplyByScalar(n,t,l),u=e.Cartesian3.negate(o,C);let d=0,p=a.length-1;for(let l=0;l<a.length;l+=3){const n=e.Cartesian3.fromArray(a,l,c),t=e.Cartesian3.add(n,u,y);i[d++]=t.x,i[d++]=t.y,i[d++]=t.z;const r=e.Cartesian3.add(n,o,y);s[p--]=r.z,s[p--]=r.y,s[p--]=r.x}return r.push(i,s),r}o.addAttribute=function(a,e,n,r){const i=e.x,s=e.y,o=e.z;t.defined(n)&&(a[n]=i,a[n+1]=s,a[n+2]=o),t.defined(r)&&(a[r]=o,a[r-1]=s,a[r-2]=i)};const M=new e.Cartesian3,T=new e.Cartesian3;o.computePositions=function(a){const t=a.granularity,s=a.positions,o=a.ellipsoid,C=a.width/2,c=a.cornerType,y=a.saveAttributes;let A=d,B=p,N=m,L=g,V=f,O=h,R=w,Q=x,U=z,G=P,v=[];const I=y?[]:void 0,q=y?[]:void 0;let j,k=s[0],F=s[1];B=e.Cartesian3.normalize(e.Cartesian3.subtract(F,k,B),B),A=o.geodeticSurfaceNormal(k,A),L=e.Cartesian3.normalize(e.Cartesian3.cross(A,B,L),L),y&&(I.push(L.x,L.y,L.z),q.push(A.x,A.y,A.z)),R=e.Cartesian3.clone(k,R),k=F,N=e.Cartesian3.negate(B,N);const H=[];let J;const K=s.length;for(J=1;J<K-1;J++){A=o.geodeticSurfaceNormal(k,A),F=s[J+1],B=e.Cartesian3.normalize(e.Cartesian3.subtract(F,k,B),B),V=e.Cartesian3.normalize(e.Cartesian3.add(B,N,V),V);const a=e.Cartesian3.multiplyByScalar(A,e.Cartesian3.dot(B,A),M);e.Cartesian3.subtract(B,a,a),e.Cartesian3.normalize(a,a);const d=e.Cartesian3.multiplyByScalar(A,e.Cartesian3.dot(N,A),T);e.Cartesian3.subtract(N,d,d),e.Cartesian3.normalize(d,d);const p=!r.CesiumMath.equalsEpsilon(Math.abs(e.Cartesian3.dot(a,d)),1,r.CesiumMath.EPSILON7);if(p){V=e.Cartesian3.cross(V,A,V),V=e.Cartesian3.cross(A,V,V),V=e.Cartesian3.normalize(V,V);const a=C/Math.max(.25,e.Cartesian3.magnitude(e.Cartesian3.cross(V,N,l))),r=n.PolylineVolumeGeometryLibrary.angleIsGreaterThanPi(B,N,k,o);V=e.Cartesian3.multiplyByScalar(V,a,V),r?(Q=e.Cartesian3.add(k,V,Q),G=e.Cartesian3.add(Q,e.Cartesian3.multiplyByScalar(L,C,G),G),U=e.Cartesian3.add(Q,e.Cartesian3.multiplyByScalar(L,2*C,U),U),u[0]=e.Cartesian3.clone(R,u[0]),u[1]=e.Cartesian3.clone(G,u[1]),j=i.PolylinePipeline.generateArc({positions:u,granularity:t,ellipsoid:o}),v=D(j,L,C,v),y&&(I.push(L.x,L.y,L.z),q.push(A.x,A.y,A.z)),O=e.Cartesian3.clone(U,O),L=e.Cartesian3.normalize(e.Cartesian3.cross(A,B,L),L),U=e.Cartesian3.add(Q,e.Cartesian3.multiplyByScalar(L,2*C,U),U),R=e.Cartesian3.add(Q,e.Cartesian3.multiplyByScalar(L,C,R),R),c===n.CornerType.ROUNDED||c===n.CornerType.BEVELED?H.push({leftPositions:E(Q,O,U,c,r)}):H.push({leftPositions:b(k,e.Cartesian3.negate(V,V),U,r)})):(U=e.Cartesian3.add(k,V,U),G=e.Cartesian3.add(U,e.Cartesian3.negate(e.Cartesian3.multiplyByScalar(L,C,G),G),G),Q=e.Cartesian3.add(U,e.Cartesian3.negate(e.Cartesian3.multiplyByScalar(L,2*C,Q),Q),Q),u[0]=e.Cartesian3.clone(R,u[0]),u[1]=e.Cartesian3.clone(G,u[1]),j=i.PolylinePipeline.generateArc({positions:u,granularity:t,ellipsoid:o}),v=D(j,L,C,v),y&&(I.push(L.x,L.y,L.z),q.push(A.x,A.y,A.z)),O=e.Cartesian3.clone(Q,O),L=e.Cartesian3.normalize(e.Cartesian3.cross(A,B,L),L),Q=e.Cartesian3.add(U,e.Cartesian3.negate(e.Cartesian3.multiplyByScalar(L,2*C,Q),Q),Q),R=e.Cartesian3.add(U,e.Cartesian3.negate(e.Cartesian3.multiplyByScalar(L,C,R),R),R),c===n.CornerType.ROUNDED||c===n.CornerType.BEVELED?H.push({rightPositions:E(U,O,Q,c,r)}):H.push({rightPositions:b(k,V,Q,r)})),N=e.Cartesian3.negate(B,N)}k=F}let W;return A=o.geodeticSurfaceNormal(k,A),u[0]=e.Cartesian3.clone(R,u[0]),u[1]=e.Cartesian3.clone(k,u[1]),j=i.PolylinePipeline.generateArc({positions:u,granularity:t,ellipsoid:o}),v=D(j,L,C,v),y&&(I.push(L.x,L.y,L.z),q.push(A.x,A.y,A.z)),c===n.CornerType.ROUNDED&&(W=S(v)),{positions:v,corners:H,lefts:I,normals:q,endPositions:W}},a.CorridorGeometryLibrary=o}));