define(["./AxisAlignedBoundingBox-8103739f","./Matrix2-fc7e9822","./defaultValue-94c3e563","./TerrainEncoding-f29761bd","./IndexDatatype-db156785","./ComponentDatatype-4a60b8d6","./RuntimeError-c581ca93","./Transforms-a076dbe6","./WebMercatorProjection-843df830","./createTaskProcessorWorker","./AttributeCompression-4d18cc04","./WebGLConstants-7dccdc96","./_commonjsHelpers-3aae1032-f55dc0c4","./combine-761d9c3f"],(function(e,t,r,n,o,i,a,s,c,h,d,u,l,I){"use strict";function m(){a.DeveloperError.throwInstantiationError()}Object.defineProperties(m.prototype,{errorEvent:{get:a.DeveloperError.throwInstantiationError},credit:{get:a.DeveloperError.throwInstantiationError},tilingScheme:{get:a.DeveloperError.throwInstantiationError},ready:{get:a.DeveloperError.throwInstantiationError},readyPromise:{get:a.DeveloperError.throwInstantiationError},hasWaterMask:{get:a.DeveloperError.throwInstantiationError},hasVertexNormals:{get:a.DeveloperError.throwInstantiationError},availability:{get:a.DeveloperError.throwInstantiationError}});const g=[];m.getRegularGridIndices=function(e,t){if(e*t>=i.CesiumMath.FOUR_GIGABYTES)throw new a.DeveloperError("The total number of vertices (width * height) must be less than 4,294,967,296.");let n=g[e];r.defined(n)||(g[e]=n=[]);let o=n[t];return r.defined(o)||(o=e*t<i.CesiumMath.SIXTY_FOUR_KILOBYTES?n[t]=new Uint16Array((e-1)*(t-1)*6):n[t]=new Uint32Array((e-1)*(t-1)*6),p(e,t,o,0)),o};const T=[];m.getRegularGridIndicesAndEdgeIndices=function(e,t){if(e*t>=i.CesiumMath.FOUR_GIGABYTES)throw new a.DeveloperError("The total number of vertices (width * height) must be less than 4,294,967,296.");let n=T[e];r.defined(n)||(T[e]=n=[]);let o=n[t];if(!r.defined(o)){const r=m.getRegularGridIndices(e,t),i=E(e,t),a=i.westIndicesSouthToNorth,s=i.southIndicesEastToWest,c=i.eastIndicesNorthToSouth,h=i.northIndicesWestToEast;o=n[t]={indices:r,westIndicesSouthToNorth:a,southIndicesEastToWest:s,eastIndicesNorthToSouth:c,northIndicesWestToEast:h}}return o};const f=[];function E(e,t){const r=new Array(t),n=new Array(e),o=new Array(t),i=new Array(e);let a;for(a=0;a<e;++a)i[a]=a,n[a]=e*t-1-a;for(a=0;a<t;++a)o[a]=(a+1)*e-1,r[a]=(t-a-1)*e;return{westIndicesSouthToNorth:r,southIndicesEastToWest:n,eastIndicesNorthToSouth:o,northIndicesWestToEast:i}}function p(e,t,r,n){let o=0;for(let i=0;i<t-1;++i){for(let t=0;t<e-1;++t){const t=o,i=t+e,a=i+1,s=t+1;r[n++]=t,r[n++]=i,r[n++]=s,r[n++]=s,r[n++]=i,r[n++]=a,++o}++o}}function w(e,t,r,n){let o=e[0];const i=e.length;for(let a=1;a<i;++a){const i=e[a];r[n++]=o,r[n++]=i,r[n++]=t,r[n++]=t,r[n++]=i,r[n++]=t+1,o=i,++t}return n}m.getRegularGridAndSkirtIndicesAndEdgeIndices=function(e,t){if(e*t>=i.CesiumMath.FOUR_GIGABYTES)throw new a.DeveloperError("The total number of vertices (width * height) must be less than 4,294,967,296.");let n=f[e];r.defined(n)||(f[e]=n=[]);let s=n[t];if(!r.defined(s)){const r=e*t,i=(e-1)*(t-1)*6,a=2*e+2*t,c=6*Math.max(0,a-4),h=r+a,d=i+c,u=E(e,t),l=u.westIndicesSouthToNorth,I=u.southIndicesEastToWest,g=u.eastIndicesNorthToSouth,T=u.northIndicesWestToEast,f=o.IndexDatatype.createTypedArray(h,d);p(e,t,f,0),m.addSkirtIndices(l,I,g,T,r,f,i),s=n[t]={indices:f,westIndicesSouthToNorth:l,southIndicesEastToWest:I,eastIndicesNorthToSouth:g,northIndicesWestToEast:T,indexCountWithoutSkirts:i}}return s},m.addSkirtIndices=function(e,t,r,n,o,i,a){let s=o;a=w(e,s,i,a),s+=e.length,a=w(t,s,i,a),s+=t.length,a=w(r,s,i,a),s+=r.length,w(n,s,i,a)},m.heightmapTerrainQuality=.25,m.getEstimatedLevelZeroGeometricErrorForAHeightmap=function(e,t,r){return 2*e.maximumRadius*Math.PI*m.heightmapTerrainQuality/(t*r)},m.prototype.requestTileGeometry=a.DeveloperError.throwInstantiationError,m.prototype.getLevelMaximumGeometricError=a.DeveloperError.throwInstantiationError,m.prototype.getTileDataAvailable=a.DeveloperError.throwInstantiationError,m.prototype.loadTileDataAvailability=a.DeveloperError.throwInstantiationError;const y=32767,N=new t.Cartesian3,S=new t.Cartesian3,b=new t.Cartesian3,M=new t.Cartographic,x=new t.Cartesian2;function A(a,h){const d=a.quantizedVertices,u=d.length/3,l=a.octEncodedNormals,I=a.westIndices.length+a.eastIndices.length+a.southIndices.length+a.northIndices.length,g=a.includeWebMercatorT,T=a.exaggeration,f=a.exaggerationRelativeHeight,E=1!==T,p=E,w=t.Rectangle.clone(a.rectangle),A=w.west,D=w.south,P=w.east,G=w.north,F=t.Ellipsoid.clone(a.ellipsoid),_=a.minimumHeight,k=a.maximumHeight,H=a.relativeToCenter,Y=s.Transforms.eastNorthUpToFixedFrame(H,F),O=t.Matrix4.inverseTransformation(Y,new t.Matrix4);let B,V;g&&(B=c.WebMercatorProjection.geodeticLatitudeToMercatorAngle(D),V=1/(c.WebMercatorProjection.geodeticLatitudeToMercatorAngle(G)-B));const R=d.subarray(0,u),L=d.subarray(u,2*u),U=d.subarray(2*u,3*u),j=r.defined(l),z=new Array(u),q=new Array(u),Q=new Array(u),K=g?new Array(u):[],X=p?new Array(u):[],Z=S;Z.x=Number.POSITIVE_INFINITY,Z.y=Number.POSITIVE_INFINITY,Z.z=Number.POSITIVE_INFINITY;const J=b;J.x=Number.NEGATIVE_INFINITY,J.y=Number.NEGATIVE_INFINITY,J.z=Number.NEGATIVE_INFINITY;let $=Number.POSITIVE_INFINITY,ee=Number.NEGATIVE_INFINITY,te=Number.POSITIVE_INFINITY,re=Number.NEGATIVE_INFINITY;for(let e=0;e<u;++e){const r=R[e],n=L[e],o=r/y,a=n/y,s=i.CesiumMath.lerp(_,k,U[e]/y);M.longitude=i.CesiumMath.lerp(A,P,o),M.latitude=i.CesiumMath.lerp(D,G,a),M.height=s,$=Math.min(M.longitude,$),ee=Math.max(M.longitude,ee),te=Math.min(M.latitude,te),re=Math.max(M.latitude,re);const h=F.cartographicToCartesian(M);z[e]=new t.Cartesian2(o,a),q[e]=s,Q[e]=h,g&&(K[e]=(c.WebMercatorProjection.geodeticLatitudeToMercatorAngle(M.latitude)-B)*V),p&&(X[e]=F.geodeticSurfaceNormal(h)),t.Matrix4.multiplyByPoint(O,h,N),t.Cartesian3.minimumByComponent(N,Z,Z),t.Cartesian3.maximumByComponent(N,J,J)}const ne=W(a.westIndices,(function(e,t){return z[e].y-z[t].y})),oe=W(a.eastIndices,(function(e,t){return z[t].y-z[e].y})),ie=W(a.southIndices,(function(e,t){return z[t].x-z[e].x})),ae=W(a.northIndices,(function(e,t){return z[e].x-z[t].x}));let se;if(_<0){const e=new n.EllipsoidalOccluder(F);se=e.computeHorizonCullingPointPossiblyUnderEllipsoid(H,Q,_)}let ce=_;ce=Math.min(ce,C(a.westIndices,a.westSkirtHeight,q,z,w,F,O,Z,J)),ce=Math.min(ce,C(a.southIndices,a.southSkirtHeight,q,z,w,F,O,Z,J)),ce=Math.min(ce,C(a.eastIndices,a.eastSkirtHeight,q,z,w,F,O,Z,J)),ce=Math.min(ce,C(a.northIndices,a.northSkirtHeight,q,z,w,F,O,Z,J));const he=new e.AxisAlignedBoundingBox(Z,J,H),de=new n.TerrainEncoding(H,he,ce,k,Y,j,g,p,T,f),ue=de.stride,le=u*ue+I*ue,Ie=new Float32Array(le);let me=0;for(let e=0;e<u;++e){if(j){const t=2*e;x.x=l[t],x.y=l[t+1]}me=de.encode(Ie,me,Q[e],z[e],q[e],x,K[e],X[e])}const ge=Math.max(0,2*(I-4)),Te=a.indices.length+3*ge,fe=o.IndexDatatype.createTypedArray(u+I,Te);fe.set(a.indices,0);const Ee=1e-4,pe=(ee-$)*Ee,we=(re-te)*Ee,ye=-pe,Ne=0,Se=pe,be=0,Me=0,xe=we,Ae=0,Ce=-we;let ve=u*ue;return v(Ie,ve,ne,de,q,z,l,F,w,a.westSkirtHeight,B,V,ye,Ne),ve+=a.westIndices.length*ue,v(Ie,ve,ie,de,q,z,l,F,w,a.southSkirtHeight,B,V,Ae,Ce),ve+=a.southIndices.length*ue,v(Ie,ve,oe,de,q,z,l,F,w,a.eastSkirtHeight,B,V,Se,be),ve+=a.eastIndices.length*ue,v(Ie,ve,ae,de,q,z,l,F,w,a.northSkirtHeight,B,V,Me,xe),m.addSkirtIndices(ne,ie,oe,ae,u,fe,a.indices.length),h.push(Ie.buffer,fe.buffer),{vertices:Ie.buffer,indices:fe.buffer,westIndicesSouthToNorth:ne,southIndicesEastToWest:ie,eastIndicesNorthToSouth:oe,northIndicesWestToEast:ae,vertexStride:ue,center:H,minimumHeight:_,maximumHeight:k,occludeePointInScaledSpace:se,encoding:de,indexCountWithoutSkirts:a.indices.length}}function C(e,r,n,o,a,s,c,h,d){let u=Number.POSITIVE_INFINITY;const l=a.north,I=a.south;let m=a.east;const g=a.west;m<g&&(m+=i.CesiumMath.TWO_PI);const T=e.length;for(let f=0;f<T;++f){const a=e[f],T=n[a],E=o[a];M.longitude=i.CesiumMath.lerp(g,m,E.x),M.latitude=i.CesiumMath.lerp(I,l,E.y),M.height=T-r;const p=s.cartographicToCartesian(M,N);t.Matrix4.multiplyByPoint(c,p,p),t.Cartesian3.minimumByComponent(p,h,h),t.Cartesian3.maximumByComponent(p,d,d),u=Math.min(u,M.height)}return u}function v(e,t,n,o,a,s,h,d,u,l,I,m,g,T){const f=r.defined(h),E=u.north,p=u.south;let w=u.east;const y=u.west;w<y&&(w+=i.CesiumMath.TWO_PI);const S=n.length;for(let r=0;r<S;++r){const u=n[r],S=a[u],b=s[u];M.longitude=i.CesiumMath.lerp(y,w,b.x)+g,M.latitude=i.CesiumMath.lerp(p,E,b.y)+T,M.height=S-l;const A=d.cartographicToCartesian(M,N);if(f){const e=2*u;x.x=h[e],x.y=h[e+1]}let C,v;o.hasWebMercatorT&&(C=(c.WebMercatorProjection.geodeticLatitudeToMercatorAngle(M.latitude)-I)*m),o.hasGeodeticSurfaceNormals&&(v=d.geodeticSurfaceNormal(A)),t=o.encode(e,t,A,b,M.height,x,C,v)}}function W(e,t){let n;return"function"===typeof e.slice&&(n=e.slice(),"function"!==typeof n.sort&&(n=void 0)),r.defined(n)||(n=Array.prototype.slice.call(e)),n.sort(t),n}var D=h(A);return D}));