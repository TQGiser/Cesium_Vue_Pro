define(["exports","./Transforms-a076dbe6","./ComponentDatatype-4a60b8d6","./defaultValue-94c3e563","./RuntimeError-c581ca93","./Matrix2-fc7e9822","./GeometryAttribute-2ecf73f6","./GeometryAttributes-7df9bef6","./GeometryPipeline-b4816e69","./IndexDatatype-db156785","./WebMercatorProjection-843df830"],(function(e,t,n,o,r,i,s,c,a,d,p){"use strict";function f(e,t,n){e=o.defaultValue(e,0),t=o.defaultValue(t,0),n=o.defaultValue(n,0),this.value=new Float32Array([e,t,n])}function u(e,t,n){let r=!n;const s=e.length;let c;if(!r&&s>1){const t=e[0].modelMatrix;for(c=1;c<s;++c)if(!i.Matrix4.equals(t,e[c].modelMatrix)){r=!0;break}}if(r)for(c=0;c<s;++c)o.defined(e[c].geometry)&&a.GeometryPipeline.transformToWorldCoordinates(e[c]);else i.Matrix4.multiplyTransformation(t,e[0].modelMatrix,t)}function l(e,t){const o=e.attributes,r=o.position,i=r.values.length/r.componentsPerAttribute;o.batchId=new s.GeometryAttribute({componentDatatype:n.ComponentDatatype.FLOAT,componentsPerAttribute:1,values:new Float32Array(i)});const c=o.batchId.values;for(let n=0;n<i;++n)c[n]=t}function m(e){const t=e.length;for(let n=0;n<t;++n){const t=e[n];o.defined(t.geometry)?l(t.geometry,n):o.defined(t.westHemisphereGeometry)&&o.defined(t.eastHemisphereGeometry)&&(l(t.westHemisphereGeometry,n),l(t.eastHemisphereGeometry,n))}}function h(e){const i=e.instances,s=e.projection,c=e.elementIndexUintSupported,d=e.scene3DOnly,p=e.vertexCacheOptimize,f=e.compressVertices,l=e.modelMatrix;let h,g,y,b=i.length;for(h=0;h<b;++h)if(o.defined(i[h].geometry)){y=i[h].geometry.primitiveType;break}for(h=1;h<b;++h)if(o.defined(i[h].geometry)&&i[h].geometry.primitiveType!==y)throw new r.DeveloperError("All instance geometries must have the same primitiveType.");if(u(i,l,d),!d)for(h=0;h<b;++h)o.defined(i[h].geometry)&&a.GeometryPipeline.splitLongitude(i[h]);if(m(i),p)for(h=0;h<b;++h){const e=i[h];o.defined(e.geometry)?(a.GeometryPipeline.reorderForPostVertexCache(e.geometry),a.GeometryPipeline.reorderForPreVertexCache(e.geometry)):o.defined(e.westHemisphereGeometry)&&o.defined(e.eastHemisphereGeometry)&&(a.GeometryPipeline.reorderForPostVertexCache(e.westHemisphereGeometry),a.GeometryPipeline.reorderForPreVertexCache(e.westHemisphereGeometry),a.GeometryPipeline.reorderForPostVertexCache(e.eastHemisphereGeometry),a.GeometryPipeline.reorderForPreVertexCache(e.eastHemisphereGeometry))}let x=a.GeometryPipeline.combineInstances(i);for(b=x.length,h=0;h<b;++h){g=x[h];const e=g.attributes;if(d)for(const t in e)e.hasOwnProperty(t)&&e[t].componentDatatype===n.ComponentDatatype.DOUBLE&&a.GeometryPipeline.encodeAttribute(g,t,`${t}3DHigh`,`${t}3DLow`);else for(const r in e)if(e.hasOwnProperty(r)&&e[r].componentDatatype===n.ComponentDatatype.DOUBLE){const e=`${r}3D`,n=`${r}2D`;a.GeometryPipeline.projectTo2D(g,r,e,n,s),o.defined(g.boundingSphere)&&"position"===r&&(g.boundingSphereCV=t.BoundingSphere.fromVertices(g.attributes.position2D.values)),a.GeometryPipeline.encodeAttribute(g,e,`${e}High`,`${e}Low`),a.GeometryPipeline.encodeAttribute(g,n,`${n}High`,`${n}Low`)}f&&a.GeometryPipeline.compressVertices(g)}if(!c){let e=[];for(b=x.length,h=0;h<b;++h)g=x[h],e=e.concat(a.GeometryPipeline.fitToUnsignedShortIndices(g));x=e}return x}function g(e,t,n,r){let i,s,c;const a=r.length-1;if(a>=0){const e=r[a];i=e.offset+e.count,c=e.index,s=n[c].indices.length}else i=0,c=0,s=n[c].indices.length;const d=e.length;for(let p=0;p<d;++p){const a=e[p],d=a[t];if(!o.defined(d))continue;const f=d.indices.length;i+f>s&&(i=0,s=n[++c].indices.length),r.push({index:c,offset:i,count:f}),i+=f}}function y(e,t){const n=[];return g(e,"geometry",t,n),g(e,"westHemisphereGeometry",t,n),g(e,"eastHemisphereGeometry",t,n),n}Object.defineProperties(f.prototype,{componentDatatype:{get:function(){return n.ComponentDatatype.FLOAT}},componentsPerAttribute:{get:function(){return 3}},normalize:{get:function(){return!1}}}),f.fromCartesian3=function(e){return r.Check.defined("offset",e),new f(e.x,e.y,e.z)},f.toValue=function(e,t){return r.Check.defined("offset",e),o.defined(t)||(t=new Float32Array([e.x,e.y,e.z])),t[0]=e.x,t[1]=e.y,t[2]=e.z,t};const b={};function x(e,t){const n=e.attributes;for(const r in n)if(n.hasOwnProperty(r)){const e=n[r];o.defined(e)&&o.defined(e.values)&&t.push(e.values.buffer)}o.defined(e.indices)&&t.push(e.indices.buffer)}function G(e,t){const n=e.length;for(let o=0;o<n;++o)x(e[o],t)}function S(e){let n=1;const r=e.length;for(let i=0;i<r;i++){const r=e[i];if(++n,!o.defined(r))continue;const s=r.attributes;n+=7+2*t.BoundingSphere.packedLength+(o.defined(r.indices)?r.indices.length:0);for(const e in s)if(s.hasOwnProperty(e)&&o.defined(s[e])){const t=s[e];n+=5+t.values.length}}return n}function P(e,t){const n=e.length,r=new Float64Array(1+19*n);let s=0;r[s++]=n;for(let c=0;c<n;c++){const t=e[c];if(i.Matrix4.pack(t.modelMatrix,r,s),s+=i.Matrix4.packedLength,o.defined(t.attributes)&&o.defined(t.attributes.offset)){const e=t.attributes.offset.value;r[s]=e[0],r[s+1]=e[1],r[s+2]=e[2]}s+=3}return t.push(r.buffer),r}function k(e){const t=e,n=new Array(t[0]);let r=0,s=1;while(s<t.length){const e=i.Matrix4.unpack(t,s);let c;s+=i.Matrix4.packedLength,o.defined(t[s])&&(c={offset:new f(t[s],t[s+1],t[s+2])}),s+=3,n[r++]={modelMatrix:e,attributes:c}}return n}function C(e){const n=e.length,r=1+(t.BoundingSphere.packedLength+1)*n,i=new Float32Array(r);let s=0;i[s++]=n;for(let c=0;c<n;++c){const n=e[c];o.defined(n)?(i[s++]=1,t.BoundingSphere.pack(e[c],i,s)):i[s++]=0,s+=t.BoundingSphere.packedLength}return i}function w(e){const n=new Array(e[0]);let o=0,r=1;while(r<e.length)1===e[r++]&&(n[o]=t.BoundingSphere.unpack(e,r)),++o,r+=t.BoundingSphere.packedLength;return n}b.combineGeometry=function(e){let n,r;const i=e.instances,s=i.length;let c,d,p=!1;s>0&&(n=h(e),n.length>0&&(r=a.GeometryPipeline.createAttributeLocations(n[0]),e.createPickOffsets&&(c=y(i,n))),o.defined(i[0].attributes)&&o.defined(i[0].attributes.offset)&&(d=new Array(s),p=!0));const f=new Array(s),u=new Array(s);for(let a=0;a<s;++a){const e=i[a],n=e.geometry;o.defined(n)&&(f[a]=n.boundingSphere,u[a]=n.boundingSphereCV,p&&(d[a]=e.geometry.offsetAttribute));const r=e.eastHemisphereGeometry,s=e.westHemisphereGeometry;o.defined(r)&&o.defined(s)&&(o.defined(r.boundingSphere)&&o.defined(s.boundingSphere)&&(f[a]=t.BoundingSphere.union(r.boundingSphere,s.boundingSphere)),o.defined(r.boundingSphereCV)&&o.defined(s.boundingSphereCV)&&(u[a]=t.BoundingSphere.union(r.boundingSphereCV,s.boundingSphereCV)))}return{geometries:n,modelMatrix:e.modelMatrix,attributeLocations:r,pickOffsets:c,offsetInstanceExtend:d,boundingSpheres:f,boundingSpheresCV:u}},b.packCreateGeometryResults=function(e,n){const r=new Float64Array(S(e)),i=[],s={},c=e.length;let a=0;r[a++]=c;for(let d=0;d<c;d++){const n=e[d],c=o.defined(n);if(r[a++]=c?1:0,!c)continue;r[a++]=n.primitiveType,r[a++]=n.geometryType,r[a++]=o.defaultValue(n.offsetAttribute,-1);const p=o.defined(n.boundingSphere)?1:0;r[a++]=p,p&&t.BoundingSphere.pack(n.boundingSphere,r,a),a+=t.BoundingSphere.packedLength;const f=o.defined(n.boundingSphereCV)?1:0;r[a++]=f,f&&t.BoundingSphere.pack(n.boundingSphereCV,r,a),a+=t.BoundingSphere.packedLength;const u=n.attributes,l=[];for(const e in u)u.hasOwnProperty(e)&&o.defined(u[e])&&(l.push(e),o.defined(s[e])||(s[e]=i.length,i.push(e)));r[a++]=l.length;for(let e=0;e<l.length;e++){const t=l[e],n=u[t];r[a++]=s[t],r[a++]=n.componentDatatype,r[a++]=n.componentsPerAttribute,r[a++]=n.normalize?1:0,r[a++]=n.values.length,r.set(n.values,a),a+=n.values.length}const m=o.defined(n.indices)?n.indices.length:0;r[a++]=m,m>0&&(r.set(n.indices,a),a+=m)}return n.push(r.buffer),{stringTable:i,packedData:r}},b.unpackCreateGeometryResults=function(e){const o=e.stringTable,r=e.packedData;let i;const a=new Array(r[0]);let p=0,f=1;while(f<r.length){const e=1===r[f++];if(!e){a[p++]=void 0;continue}const u=r[f++],l=r[f++];let m,h,g=r[f++];-1===g&&(g=void 0);const y=1===r[f++];y&&(m=t.BoundingSphere.unpack(r,f)),f+=t.BoundingSphere.packedLength;const b=1===r[f++];let x,G,S;b&&(h=t.BoundingSphere.unpack(r,f)),f+=t.BoundingSphere.packedLength;const P=new c.GeometryAttributes,k=r[f++];for(i=0;i<k;i++){const e=o[r[f++]],t=r[f++];S=r[f++];const i=0!==r[f++];x=r[f++],G=n.ComponentDatatype.createTypedArray(t,x);for(let n=0;n<x;n++)G[n]=r[f++];P[e]=new s.GeometryAttribute({componentDatatype:t,componentsPerAttribute:S,normalize:i,values:G})}let C;if(x=r[f++],x>0){const e=G.length/S;for(C=d.IndexDatatype.createTypedArray(e,x),i=0;i<x;i++)C[i]=r[f++]}a[p++]=new s.Geometry({primitiveType:u,geometryType:l,boundingSphere:m,boundingSphereCV:h,indices:C,attributes:P,offsetAttribute:g})}return a},b.packCombineGeometryParameters=function(e,n){const o=e.createGeometryResults,r=o.length;for(let t=0;t<r;t++)n.push(o[t].packedData.buffer);return{createGeometryResults:e.createGeometryResults,packedInstances:P(e.instances,n),ellipsoid:e.ellipsoid,isGeographic:e.projection instanceof t.GeographicProjection,elementIndexUintSupported:e.elementIndexUintSupported,scene3DOnly:e.scene3DOnly,vertexCacheOptimize:e.vertexCacheOptimize,compressVertices:e.compressVertices,modelMatrix:e.modelMatrix,createPickOffsets:e.createPickOffsets}},b.unpackCombineGeometryParameters=function(e){const n=k(e.packedInstances),o=e.createGeometryResults,r=o.length;let s=0;for(let t=0;t<r;t++){const e=b.unpackCreateGeometryResults(o[t]),r=e.length;for(let t=0;t<r;t++){const o=e[t],r=n[s];r.geometry=o,++s}}const c=i.Ellipsoid.clone(e.ellipsoid),a=e.isGeographic?new t.GeographicProjection(c):new p.WebMercatorProjection(c);return{instances:n,ellipsoid:c,projection:a,elementIndexUintSupported:e.elementIndexUintSupported,scene3DOnly:e.scene3DOnly,vertexCacheOptimize:e.vertexCacheOptimize,compressVertices:e.compressVertices,modelMatrix:i.Matrix4.clone(e.modelMatrix),createPickOffsets:e.createPickOffsets}},b.packCombineGeometryResults=function(e,t){o.defined(e.geometries)&&G(e.geometries,t);const n=C(e.boundingSpheres),r=C(e.boundingSpheresCV);return t.push(n.buffer,r.buffer),{geometries:e.geometries,attributeLocations:e.attributeLocations,modelMatrix:e.modelMatrix,pickOffsets:e.pickOffsets,offsetInstanceExtend:e.offsetInstanceExtend,boundingSpheres:n,boundingSpheresCV:r}},b.unpackCombineGeometryResults=function(e){return{geometries:e.geometries,attributeLocations:e.attributeLocations,modelMatrix:e.modelMatrix,pickOffsets:e.pickOffsets,offsetInstanceExtend:e.offsetInstanceExtend,boundingSpheres:w(e.boundingSpheres),boundingSpheresCV:w(e.boundingSpheresCV)}},e.PrimitivePipeline=b}));