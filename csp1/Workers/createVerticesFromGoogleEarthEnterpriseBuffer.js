define(["./AxisAlignedBoundingBox-8103739f","./Transforms-a076dbe6","./Matrix2-fc7e9822","./defaultValue-94c3e563","./TerrainEncoding-f29761bd","./ComponentDatatype-4a60b8d6","./OrientedBoundingBox-417528c0","./RuntimeError-c581ca93","./WebMercatorProjection-843df830","./createTaskProcessorWorker","./_commonjsHelpers-3aae1032-f55dc0c4","./combine-761d9c3f","./AttributeCompression-4d18cc04","./WebGLConstants-7dccdc96","./EllipsoidTangentPlane-d2c0c530","./IntersectionTests-5deed78b","./Plane-e20fba8c"],(function(t,e,n,i,o,r,a,s,c,u,h,d,l,g,m,p,I){"use strict";const f=Uint16Array.BYTES_PER_ELEMENT,E=Int32Array.BYTES_PER_ELEMENT,T=Uint32Array.BYTES_PER_ELEMENT,C=Float32Array.BYTES_PER_ELEMENT,M=Float64Array.BYTES_PER_ELEMENT;function x(t,e,n){n=i.defaultValue(n,r.CesiumMath);const o=t.length;for(let i=0;i<o;++i)if(n.equalsEpsilon(t[i],e,r.CesiumMath.EPSILON12))return i;return-1}function N(t,e){t.ellipsoid=n.Ellipsoid.clone(t.ellipsoid),t.rectangle=n.Rectangle.clone(t.rectangle);const i=A(t.buffer,t.relativeToCenter,t.ellipsoid,t.rectangle,t.nativeRectangle,t.exaggeration,t.exaggerationRelativeHeight,t.skirtHeight,t.includeWebMercatorT,t.negativeAltitudeExponentBias,t.negativeElevationThreshold),o=i.vertices;e.push(o.buffer);const r=i.indices;return e.push(r.buffer),{vertices:o.buffer,indices:r.buffer,numberOfAttributes:i.encoding.stride,minimumHeight:i.minimumHeight,maximumHeight:i.maximumHeight,boundingSphere3D:i.boundingSphere3D,orientedBoundingBox:i.orientedBoundingBox,occludeePointInScaledSpace:i.occludeePointInScaledSpace,encoding:i.encoding,vertexCountWithoutSkirts:i.vertexCountWithoutSkirts,indexCountWithoutSkirts:i.indexCountWithoutSkirts,westIndicesSouthToNorth:i.westIndicesSouthToNorth,southIndicesEastToWest:i.southIndicesEastToWest,eastIndicesNorthToSouth:i.eastIndicesNorthToSouth,northIndicesWestToEast:i.northIndicesWestToEast}}const b=new n.Cartographic,S=new n.Cartesian3,w=new n.Cartesian3,B=new n.Cartesian3,P=new n.Matrix4;function A(u,h,d,l,g,m,p,I,N,A,R){let _,v,W,F,O,V;i.defined(l)?(_=l.west,v=l.south,W=l.east,F=l.north,O=l.width,V=l.height):(_=r.CesiumMath.toRadians(g.west),v=r.CesiumMath.toRadians(g.south),W=r.CesiumMath.toRadians(g.east),F=r.CesiumMath.toRadians(g.north),O=r.CesiumMath.toRadians(l.width),V=r.CesiumMath.toRadians(l.height));const Y=[v,F],H=[_,W],U=e.Transforms.eastNorthUpToFixedFrame(h,d),k=n.Matrix4.inverseTransformation(U,P);let L,j;N&&(L=c.WebMercatorProjection.geodeticLatitudeToMercatorAngle(v),j=1/(c.WebMercatorProjection.geodeticLatitudeToMercatorAngle(F)-L));const D=1!==m,G=D,z=new DataView(u);let q=Number.POSITIVE_INFINITY,J=Number.NEGATIVE_INFINITY;const K=w;K.x=Number.POSITIVE_INFINITY,K.y=Number.POSITIVE_INFINITY,K.z=Number.POSITIVE_INFINITY;const Q=B;Q.x=Number.NEGATIVE_INFINITY,Q.y=Number.NEGATIVE_INFINITY,Q.z=Number.NEGATIVE_INFINITY;let X,Z,$=0,tt=0,et=0;for(Z=0;Z<4;++Z){let t=$;X=z.getUint32(t,!0),t+=T;const e=r.CesiumMath.toRadians(180*z.getFloat64(t,!0));t+=M,-1===x(H,e)&&H.push(e);const n=r.CesiumMath.toRadians(180*z.getFloat64(t,!0));t+=M,-1===x(Y,n)&&Y.push(n),t+=2*M;let i=z.getInt32(t,!0);t+=E,tt+=i,i=z.getInt32(t,!0),et+=3*i,$+=X+T}const nt=[],it=[],ot=new Array(tt),rt=new Array(tt),at=new Array(tt),st=N?new Array(tt):[],ct=G?new Array(tt):[],ut=new Array(et),ht=[],dt=[],lt=[],gt=[];let mt=0,pt=0;for($=0,Z=0;Z<4;++Z){X=z.getUint32($,!0),$+=T;const t=$,e=r.CesiumMath.toRadians(180*z.getFloat64($,!0));$+=M;const i=r.CesiumMath.toRadians(180*z.getFloat64($,!0));$+=M;const o=r.CesiumMath.toRadians(180*z.getFloat64($,!0)),a=.5*o;$+=M;const u=r.CesiumMath.toRadians(180*z.getFloat64($,!0)),h=.5*u;$+=M;const l=z.getInt32($,!0);$+=E;const g=z.getInt32($,!0);$+=E,$+=E;const m=new Array(l);for(let s=0;s<l;++s){const t=e+z.getUint8($++)*o;b.longitude=t;const l=i+z.getUint8($++)*u;b.latitude=l;let g=z.getFloat32($,!0);if($+=C,0!==g&&g<R&&(g*=-Math.pow(2,A)),g*=6371010,b.height=g,-1!==x(H,t)||-1!==x(Y,l)){const t=x(nt,b,n.Cartographic);if(-1!==t){m[s]=it[t];continue}nt.push(n.Cartographic.clone(b)),it.push(mt)}m[s]=mt,Math.abs(t-_)<a?ht.push({index:mt,cartographic:n.Cartographic.clone(b)}):Math.abs(t-W)<a?lt.push({index:mt,cartographic:n.Cartographic.clone(b)}):Math.abs(l-v)<h?dt.push({index:mt,cartographic:n.Cartographic.clone(b)}):Math.abs(l-F)<h&&gt.push({index:mt,cartographic:n.Cartographic.clone(b)}),q=Math.min(g,q),J=Math.max(g,J),at[mt]=g;const p=d.cartographicToCartesian(b);if(ot[mt]=p,N&&(st[mt]=(c.WebMercatorProjection.geodeticLatitudeToMercatorAngle(l)-L)*j),G){const t=d.geodeticSurfaceNormal(p);ct[mt]=t}n.Matrix4.multiplyByPoint(k,p,S),n.Cartesian3.minimumByComponent(S,K,K),n.Cartesian3.maximumByComponent(S,Q,Q);let I=(t-_)/(W-_);I=r.CesiumMath.clamp(I,0,1);let f=(l-v)/(F-v);f=r.CesiumMath.clamp(f,0,1),rt[mt]=new n.Cartesian2(I,f),++mt}const p=3*g;for(let n=0;n<p;++n,++pt)ut[pt]=m[z.getUint16($,!0)],$+=f;if(X!==$-t)throw new s.RuntimeError("Invalid terrain tile.")}ot.length=mt,rt.length=mt,at.length=mt,N&&(st.length=mt),G&&(ct.length=mt);const It=mt,ft=pt,Et={hMin:q,lastBorderPoint:void 0,skirtHeight:I,toENU:k,ellipsoid:d,minimum:K,maximum:Q};ht.sort((function(t,e){return e.cartographic.latitude-t.cartographic.latitude})),dt.sort((function(t,e){return t.cartographic.longitude-e.cartographic.longitude})),lt.sort((function(t,e){return t.cartographic.latitude-e.cartographic.latitude})),gt.sort((function(t,e){return e.cartographic.longitude-t.cartographic.longitude}));const Tt=1e-5;if(y(ot,at,rt,st,ct,ut,Et,ht,-Tt*O,!0,-Tt*V),y(ot,at,rt,st,ct,ut,Et,dt,-Tt*V,!1),y(ot,at,rt,st,ct,ut,Et,lt,Tt*O,!0,Tt*V),y(ot,at,rt,st,ct,ut,Et,gt,Tt*V,!1),ht.length>0&&gt.length>0){const t=ht[0].index,e=It,n=gt[gt.length-1].index,i=ot.length-1;ut.push(n,i,e,e,t,n)}tt=ot.length;const Ct=e.BoundingSphere.fromPoints(ot);let Mt;i.defined(l)&&(Mt=a.OrientedBoundingBox.fromRectangle(l,q,J,d));const xt=new o.EllipsoidalOccluder(d),Nt=xt.computeHorizonCullingPointPossiblyUnderEllipsoid(h,ot,q),bt=new t.AxisAlignedBoundingBox(K,Q,h),St=new o.TerrainEncoding(h,bt,Et.hMin,J,U,!1,N,G,m,p),wt=new Float32Array(tt*St.stride);let Bt=0;for(let t=0;t<tt;++t)Bt=St.encode(wt,Bt,ot[t],rt[t],at[t],void 0,st[t],ct[t]);const Pt=ht.map((function(t){return t.index})).reverse(),At=dt.map((function(t){return t.index})).reverse(),yt=lt.map((function(t){return t.index})).reverse(),Rt=gt.map((function(t){return t.index})).reverse();return At.unshift(yt[yt.length-1]),At.push(Pt[0]),Rt.unshift(Pt[Pt.length-1]),Rt.push(yt[0]),{vertices:wt,indices:new Uint16Array(ut),maximumHeight:J,minimumHeight:q,encoding:St,boundingSphere3D:Ct,orientedBoundingBox:Mt,occludeePointInScaledSpace:Nt,vertexCountWithoutSkirts:It,indexCountWithoutSkirts:ft,westIndicesSouthToNorth:Pt,southIndicesEastToWest:At,eastIndicesNorthToSouth:yt,northIndicesWestToEast:Rt}}function y(t,e,o,a,s,c,u,h,d,l,g){const m=h.length;for(let p=0;p<m;++p){const I=h[p],f=I.cartographic,E=I.index,T=t.length,C=f.longitude;let M=f.latitude;M=r.CesiumMath.clamp(M,-r.CesiumMath.PI_OVER_TWO,r.CesiumMath.PI_OVER_TWO);const x=f.height-u.skirtHeight;u.hMin=Math.min(u.hMin,x),n.Cartographic.fromRadians(C,M,x,b),l&&(b.longitude+=d),l?p===m-1?b.latitude+=g:0===p&&(b.latitude-=g):b.latitude+=d;const N=u.ellipsoid.cartographicToCartesian(b);t.push(N),e.push(x),o.push(n.Cartesian2.clone(o[E])),a.length>0&&a.push(a[E]),s.length>0&&s.push(s[E]),n.Matrix4.multiplyByPoint(u.toENU,N,S);const w=u.minimum,B=u.maximum;n.Cartesian3.minimumByComponent(S,w,w),n.Cartesian3.maximumByComponent(S,B,B);const P=u.lastBorderPoint;if(i.defined(P)){const t=P.index;c.push(t,T-1,T,T,E,t)}u.lastBorderPoint=I}}var R=u(N);return R}));