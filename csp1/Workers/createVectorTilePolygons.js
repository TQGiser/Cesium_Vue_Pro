define(["./AttributeCompression-4d18cc04","./Matrix2-fc7e9822","./Color-ec9112c4","./defaultValue-94c3e563","./IndexDatatype-db156785","./ComponentDatatype-4a60b8d6","./OrientedBoundingBox-417528c0","./createTaskProcessorWorker","./RuntimeError-c581ca93","./Transforms-a076dbe6","./_commonjsHelpers-3aae1032-f55dc0c4","./combine-761d9c3f","./WebGLConstants-7dccdc96","./EllipsoidTangentPlane-d2c0c530","./AxisAlignedBoundingBox-8103739f","./IntersectionTests-5deed78b","./Plane-e20fba8c"],(function(e,t,n,a,r,o,s,i,c,d,f,l,u,h,g,p,b){"use strict";const m=new t.Cartesian3,y=new t.Ellipsoid,C=new t.Rectangle,I={min:void 0,max:void 0,indexBytesPerElement:void 0};function x(e){const n=new Float64Array(e);let a=0;I.indexBytesPerElement=n[a++],I.min=n[a++],I.max=n[a++],t.Cartesian3.unpack(n,a,m),a+=t.Cartesian3.packedLength,t.Ellipsoid.unpack(n,a,y),a+=t.Ellipsoid.packedLength,t.Rectangle.unpack(n,a,C)}function w(e){const t=e.length;let a=0;for(let r=0;r<t;++r)a+=n.Color.packedLength+3+e[r].batchIds.length;return a}function A(e,t,a){const r=t.length,o=2+r*s.OrientedBoundingBox.packedLength+1+w(a),i=new Float64Array(o);let c=0;i[c++]=e,i[c++]=r;for(let n=0;n<r;++n)s.OrientedBoundingBox.pack(t[n],i,c),c+=s.OrientedBoundingBox.packedLength;const d=a.length;i[c++]=d;for(let s=0;s<d;++s){const e=a[s];n.Color.pack(e.color,i,c),c+=n.Color.packedLength,i[c++]=e.offset,i[c++]=e.count;const t=e.batchIds,r=t.length;i[c++]=r;for(let n=0;n<r;++n)i[c++]=t[n]}return i}const E=32767,N=new t.Cartesian3,T=new t.Cartesian3,B=new t.Cartesian3,k=new t.Cartesian3,L=new t.Cartesian3,O=new t.Cartographic,U=new t.Rectangle;function P(i,c){let d;x(i.packedBuffer);const f=I.indexBytesPerElement;d=2===f?new Uint16Array(i.indices):new Uint32Array(i.indices);const l=new Uint16Array(i.positions),u=new Uint32Array(i.counts),h=new Uint32Array(i.indexCounts),g=new Uint32Array(i.batchIds),p=new Uint32Array(i.batchTableColors),b=new Array(u.length),w=m,P=y;let F=C;const S=I.min,D=I.max;let R,_,M,G=i.minimumHeights,V=i.maximumHeights;a.defined(G)&&a.defined(V)&&(G=new Float32Array(G),V=new Float32Array(V));const Y=l.length/2,v=l.subarray(0,Y),H=l.subarray(Y,2*Y);e.AttributeCompression.zigZagDeltaDecode(v,H);const W=new Float64Array(3*Y);for(R=0;R<Y;++R){const e=v[R],n=H[R],a=o.CesiumMath.lerp(F.west,F.east,e/E),r=o.CesiumMath.lerp(F.south,F.north,n/E),s=t.Cartographic.fromRadians(a,r,0,O),i=P.cartographicToCartesian(s,N);t.Cartesian3.pack(i,W,3*R)}const j=u.length,z=new Array(j),Z=new Array(j);let q=0,J=0;for(R=0;R<j;++R)z[R]=q,Z[R]=J,q+=u[R],J+=h[R];const K=new Float32Array(3*Y*2),Q=new Uint16Array(2*Y),X=new Uint32Array(Z.length),$=new Uint32Array(h.length);let ee=[];const te={};for(R=0;R<j;++R)M=p[R],a.defined(te[M])?(te[M].positionLength+=u[R],te[M].indexLength+=h[R],te[M].batchIds.push(R)):te[M]={positionLength:u[R],indexLength:h[R],offset:0,indexOffset:0,batchIds:[R]};let ne,ae=0,re=0;for(M in te)if(te.hasOwnProperty(M)){ne=te[M],ne.offset=ae,ne.indexOffset=re;const e=2*ne.positionLength,t=2*ne.indexLength+6*ne.positionLength;ae+=e,re+=t,ne.indexLength=t}const oe=[];for(M in te)te.hasOwnProperty(M)&&(ne=te[M],oe.push({color:n.Color.fromRgba(parseInt(M)),offset:ne.indexOffset,count:ne.indexLength,batchIds:ne.batchIds}));for(R=0;R<j;++R){M=p[R],ne=te[M];const e=ne.offset;let n=3*e,r=e;const o=z[R],i=u[R],c=g[R];let f=S,l=D;a.defined(G)&&a.defined(V)&&(f=G[R],l=V[R]);let m=Number.POSITIVE_INFINITY,y=Number.NEGATIVE_INFINITY,C=Number.POSITIVE_INFINITY,I=Number.NEGATIVE_INFINITY;for(_=0;_<i;++_){const e=t.Cartesian3.unpack(W,3*o+3*_,N);P.scaleToGeodeticSurface(e,e);const a=P.cartesianToCartographic(e,O),s=a.latitude,i=a.longitude;m=Math.min(s,m),y=Math.max(s,y),C=Math.min(i,C),I=Math.max(i,I);const d=P.geodeticSurfaceNormal(e,T);let u=t.Cartesian3.multiplyByScalar(d,f,B);const h=t.Cartesian3.add(e,u,k);u=t.Cartesian3.multiplyByScalar(d,l,u);const g=t.Cartesian3.add(e,u,L);t.Cartesian3.subtract(g,w,g),t.Cartesian3.subtract(h,w,h),t.Cartesian3.pack(g,K,n),t.Cartesian3.pack(h,K,n+3),Q[r]=c,Q[r+1]=c,n+=6,r+=2}F=U,F.west=C,F.east=I,F.south=m,F.north=y,b[R]=s.OrientedBoundingBox.fromRectangle(F,S,D,P);let x=ne.indexOffset;const A=Z[R],E=h[R];for(X[R]=x,_=0;_<E;_+=3){const t=d[A+_]-o,n=d[A+_+1]-o,a=d[A+_+2]-o;ee[x++]=2*t+e,ee[x++]=2*n+e,ee[x++]=2*a+e,ee[x++]=2*a+1+e,ee[x++]=2*n+1+e,ee[x++]=2*t+1+e}for(_=0;_<i;++_){const t=_,n=(_+1)%i;ee[x++]=2*t+1+e,ee[x++]=2*n+e,ee[x++]=2*t+e,ee[x++]=2*t+1+e,ee[x++]=2*n+1+e,ee[x++]=2*n+e}ne.offset+=2*i,ne.indexOffset=x,$[R]=x-X[R]}ee=r.IndexDatatype.createTypedArray(K.length/3,ee);const se=oe.length;for(let e=0;e<se;++e){const t=oe[e].batchIds;let n=0;const a=t.length;for(let e=0;e<a;++e)n+=$[t[e]];oe[e].count=n}const ie=2===ee.BYTES_PER_ELEMENT?r.IndexDatatype.UNSIGNED_SHORT:r.IndexDatatype.UNSIGNED_INT,ce=A(ie,b,oe);return c.push(K.buffer,ee.buffer,X.buffer,$.buffer,Q.buffer,ce.buffer),{positions:K.buffer,indices:ee.buffer,indexOffsets:X.buffer,indexCounts:$.buffer,batchIds:Q.buffer,packedBuffer:ce.buffer}}var F=i(P);return F}));