define(["./AttributeCompression-4d18cc04","./Matrix2-fc7e9822","./combine-761d9c3f","./IndexDatatype-db156785","./ComponentDatatype-4a60b8d6","./createTaskProcessorWorker","./RuntimeError-c581ca93","./defaultValue-94c3e563","./WebGLConstants-7dccdc96"],(function(t,e,a,s,n,r,i,o,c){"use strict";const d=32767,l=Math.cos(n.CesiumMath.toRadians(150)),f=new e.Cartographic,u=new e.Cartesian3;function h(t,a,s,r,i,o,c){const l=t.length,h=new Float64Array(3*l);for(let C=0;C<l;++C){const l=t[C],p=a[C],m=s[C],b=n.CesiumMath.lerp(r.west,r.east,l/d),A=n.CesiumMath.lerp(r.south,r.north,p/d),w=n.CesiumMath.lerp(i,o,m/d),g=e.Cartographic.fromRadians(b,A,w,f),y=c.cartographicToCartesian(g,u);e.Cartesian3.pack(y,h,3*C)}return h}function C(t){const e=t.length,a=new Uint32Array(e+1);let s=0;for(let n=0;n<e;++n)a[n]=s,s+=t[n];return a[e]=s,a}const p=new e.Cartographic,m=new e.Cartographic;function b(t,a,s,n){const r=n.length,i=t.length,o=new Uint8Array(i),c=p,d=m;let l=0;for(let u=0;u<r;u++){const s=n[u];let r=s;for(let n=1;n<s;n++){const s=l+n,i=s-1;d.longitude=t[s],d.latitude=a[s],c.longitude=t[i],c.latitude=a[i],e.Cartographic.equals(d,c)&&(r--,o[i]=1)}n[u]=r,l+=s}let f=0;for(let e=0;e<i;e++)1!==o[e]&&(t[f]=t[e],a[f]=a[e],s[f]=s[e],f++)}function A(t){const e=8*t,a=3*e,n=4*e;this.startEllipsoidNormals=new Float32Array(a),this.endEllipsoidNormals=new Float32Array(a),this.startPositionAndHeights=new Float32Array(n),this.startFaceNormalAndVertexCornerIds=new Float32Array(n),this.endPositionAndHeights=new Float32Array(n),this.endFaceNormalAndHalfWidths=new Float32Array(n),this.vertexBatchIds=new Uint16Array(e),this.indices=s.IndexDatatype.createTypedArray(e,36*t),this.vec3Offset=0,this.vec4Offset=0,this.batchIdOffset=0,this.indexOffset=0,this.volumeStartIndex=0}const w=new e.Cartesian3,g=new e.Cartesian3;function y(t,a,s,n,r){const i=e.Cartesian3.subtract(s,a,g);let o=e.Cartesian3.subtract(a,t,w);return e.Cartesian3.normalize(i,i),e.Cartesian3.normalize(o,o),e.Cartesian3.dot(i,o)<l&&(o=e.Cartesian3.multiplyByScalar(o,-1,w)),e.Cartesian3.add(i,o,r),e.Cartesian3.equals(r,e.Cartesian3.ZERO)&&(r=e.Cartesian3.subtract(t,a)),e.Cartesian3.cross(r,n,r),e.Cartesian3.cross(n,r,r),e.Cartesian3.normalize(r,r),r}const N=[0,2,6,0,6,4,0,1,3,0,3,2,0,4,5,0,5,1,5,3,1,5,7,3,7,5,4,7,4,6,7,6,2,7,2,3],k=N.length,I=new e.Cartesian3,x=new e.Cartesian3,E=new e.Cartesian3,F=new e.Cartesian3,H=new e.Cartesian3;A.prototype.addVolume=function(t,a,s,n,r,i,o,c,d,l){let f=e.Cartesian3.add(a,d,I);const u=l.geodeticSurfaceNormal(f,x);f=e.Cartesian3.add(s,d,I);const h=l.geodeticSurfaceNormal(f,F),C=y(t,a,s,u,E),p=y(n,s,a,h,H),m=this.startEllipsoidNormals,b=this.endEllipsoidNormals,A=this.startPositionAndHeights,w=this.startFaceNormalAndVertexCornerIds,g=this.endPositionAndHeights,v=this.endFaceNormalAndHalfWidths,O=this.vertexBatchIds;let P,D=this.batchIdOffset,S=this.vec3Offset,M=this.vec4Offset;for(P=0;P<8;P++)e.Cartesian3.pack(u,m,S),e.Cartesian3.pack(h,b,S),e.Cartesian3.pack(a,A,M),A[M+3]=r,e.Cartesian3.pack(s,g,M),g[M+3]=i,e.Cartesian3.pack(C,w,M),w[M+3]=P,e.Cartesian3.pack(p,v,M),v[M+3]=o,O[D++]=c,S+=3,M+=4;this.batchIdOffset=D,this.vec3Offset=S,this.vec4Offset=M;const R=this.indices,U=this.volumeStartIndex,B=this.indexOffset;for(P=0;P<k;P++)R[B+P]=N[P]+U;this.volumeStartIndex+=8,this.indexOffset+=k};const v=new e.Rectangle,O=new e.Ellipsoid,P=new e.Cartesian3,D=new e.Cartesian3,S=new e.Cartesian3,M=new e.Cartesian3,R=new e.Cartesian3;function U(r,i){const o=new Uint16Array(r.positions),c=new Uint16Array(r.widths),l=new Uint32Array(r.counts),f=new Uint16Array(r.batchIds),u=v,p=O,m=P,w=new Float64Array(r.packedBuffer);let g=0;const y=w[g++],N=w[g++];let k;e.Rectangle.unpack(w,g,u),g+=e.Rectangle.packedLength,e.Ellipsoid.unpack(w,g,p),g+=e.Ellipsoid.packedLength,e.Cartesian3.unpack(w,g,m);let I=o.length/3;const x=o.subarray(0,I),E=o.subarray(I,2*I),F=o.subarray(2*I,3*I);t.AttributeCompression.zigZagDeltaDecode(x,E,F),b(x,E,F,l);const H=l.length;let U=0;for(k=0;k<H;k++){const t=l[k];U+=t-1}const B=new A(U),V=h(x,E,F,u,y,N,p);I=x.length;const T=new Float32Array(3*I);for(k=0;k<I;++k)T[3*k]=V[3*k]-m.x,T[3*k+1]=V[3*k+1]-m.y,T[3*k+2]=V[3*k+2]-m.z;let W=0,z=0;for(k=0;k<H;k++){const t=l[k]-1,a=.5*c[k],s=f[k],r=W;for(let i=0;i<t;i++){const o=e.Cartesian3.unpack(T,W,S),c=e.Cartesian3.unpack(T,W+3,M);let l=F[z],f=F[z+1];l=n.CesiumMath.lerp(y,N,l/d),f=n.CesiumMath.lerp(y,N,f/d),z++;let u=D,h=R;if(0===i){const a=r+3*t,s=e.Cartesian3.unpack(T,a,D);if(e.Cartesian3.equals(s,o))e.Cartesian3.unpack(T,a-3,u);else{const t=e.Cartesian3.subtract(o,c,D);u=e.Cartesian3.add(t,o,D)}}else e.Cartesian3.unpack(T,W-3,u);if(i===t-1){const t=e.Cartesian3.unpack(T,r,R);if(e.Cartesian3.equals(t,c))e.Cartesian3.unpack(T,r+3,h);else{const t=e.Cartesian3.subtract(c,o,R);h=e.Cartesian3.add(t,c,R)}}else e.Cartesian3.unpack(T,W+6,h);B.addVolume(u,o,c,h,l,f,a,s,m,p),W+=3}W+=3,z++}const q=B.indices;i.push(B.startEllipsoidNormals.buffer),i.push(B.endEllipsoidNormals.buffer),i.push(B.startPositionAndHeights.buffer),i.push(B.startFaceNormalAndVertexCornerIds.buffer),i.push(B.endPositionAndHeights.buffer),i.push(B.endFaceNormalAndHalfWidths.buffer),i.push(B.vertexBatchIds.buffer),i.push(q.buffer);let L={indexDatatype:2===q.BYTES_PER_ELEMENT?s.IndexDatatype.UNSIGNED_SHORT:s.IndexDatatype.UNSIGNED_INT,startEllipsoidNormals:B.startEllipsoidNormals.buffer,endEllipsoidNormals:B.endEllipsoidNormals.buffer,startPositionAndHeights:B.startPositionAndHeights.buffer,startFaceNormalAndVertexCornerIds:B.startFaceNormalAndVertexCornerIds.buffer,endPositionAndHeights:B.endPositionAndHeights.buffer,endFaceNormalAndHalfWidths:B.endFaceNormalAndHalfWidths.buffer,vertexBatchIds:B.vertexBatchIds.buffer,indices:q.buffer};if(r.keepDecodedPositions){const t=C(l);i.push(V.buffer,t.buffer),L=a.combine(L,{decodedPositions:V.buffer,decodedPositionOffsets:t.buffer})}return L}var B=r(U);return B}));