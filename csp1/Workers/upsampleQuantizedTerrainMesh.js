define(["./AttributeCompression-4d18cc04","./Transforms-a076dbe6","./Matrix2-fc7e9822","./defaultValue-94c3e563","./TerrainEncoding-f29761bd","./IndexDatatype-db156785","./RuntimeError-c581ca93","./ComponentDatatype-4a60b8d6","./OrientedBoundingBox-417528c0","./createTaskProcessorWorker","./_commonjsHelpers-3aae1032-f55dc0c4","./combine-761d9c3f","./WebGLConstants-7dccdc96","./EllipsoidTangentPlane-d2c0c530","./AxisAlignedBoundingBox-8103739f","./IntersectionTests-5deed78b","./Plane-e20fba8c"],(function(e,t,i,n,r,s,o,h,u,d,p,f,l,c,a,g,m){"use strict";const w={clipTriangleAtAxisAlignedThreshold:function(e,t,i,r,s,h){if(!n.defined(e))throw new o.DeveloperError("threshold is required.");if(!n.defined(t))throw new o.DeveloperError("keepAbove is required.");if(!n.defined(i))throw new o.DeveloperError("u0 is required.");if(!n.defined(r))throw new o.DeveloperError("u1 is required.");if(!n.defined(s))throw new o.DeveloperError("u2 is required.");let u,d,p;n.defined(h)?h.length=0:h=[],t?(u=i<e,d=r<e,p=s<e):(u=i>e,d=r>e,p=s>e);const f=u+d+p;let l,c,a,g,m,w;return 1===f?u?(l=(e-i)/(r-i),c=(e-i)/(s-i),h.push(1),h.push(2),1!==c&&(h.push(-1),h.push(0),h.push(2),h.push(c)),1!==l&&(h.push(-1),h.push(0),h.push(1),h.push(l))):d?(a=(e-r)/(s-r),g=(e-r)/(i-r),h.push(2),h.push(0),1!==g&&(h.push(-1),h.push(1),h.push(0),h.push(g)),1!==a&&(h.push(-1),h.push(1),h.push(2),h.push(a))):p&&(m=(e-s)/(i-s),w=(e-s)/(r-s),h.push(0),h.push(1),1!==w&&(h.push(-1),h.push(2),h.push(1),h.push(w)),1!==m&&(h.push(-1),h.push(2),h.push(0),h.push(m))):2===f?u||i===e?d||r===e?p||s===e||(c=(e-i)/(s-i),a=(e-r)/(s-r),h.push(2),h.push(-1),h.push(0),h.push(2),h.push(c),h.push(-1),h.push(1),h.push(2),h.push(a)):(w=(e-s)/(r-s),l=(e-i)/(r-i),h.push(1),h.push(-1),h.push(2),h.push(1),h.push(w),h.push(-1),h.push(0),h.push(1),h.push(l)):(g=(e-r)/(i-r),m=(e-s)/(i-s),h.push(0),h.push(-1),h.push(1),h.push(0),h.push(g),h.push(-1),h.push(2),h.push(0),h.push(m)):3!==f&&(h.push(0),h.push(1),h.push(2)),h},computeBarycentricCoordinates:function(e,t,r,s,h,u,d,p,f){if(!n.defined(e))throw new o.DeveloperError("x is required.");if(!n.defined(t))throw new o.DeveloperError("y is required.");if(!n.defined(r))throw new o.DeveloperError("x1 is required.");if(!n.defined(s))throw new o.DeveloperError("y1 is required.");if(!n.defined(h))throw new o.DeveloperError("x2 is required.");if(!n.defined(u))throw new o.DeveloperError("y2 is required.");if(!n.defined(d))throw new o.DeveloperError("x3 is required.");if(!n.defined(p))throw new o.DeveloperError("y3 is required.");const l=r-d,c=d-h,a=u-p,g=s-p,m=1/(a*l+c*g),w=t-p,x=e-d,C=(a*x+c*w)*m,y=(-g*x+l*w)*m,v=1-C-y;return n.defined(f)?(f.x=C,f.y=y,f.z=v,f):new i.Cartesian3(C,y,v)},computeLineSegmentLineSegmentIntersection:function(e,t,r,s,h,u,d,p,f){o.Check.typeOf.number("x00",e),o.Check.typeOf.number("y00",t),o.Check.typeOf.number("x01",r),o.Check.typeOf.number("y01",s),o.Check.typeOf.number("x10",h),o.Check.typeOf.number("y10",u),o.Check.typeOf.number("x11",d),o.Check.typeOf.number("y11",p);const l=(d-h)*(t-u)-(p-u)*(e-h),c=(r-e)*(t-u)-(s-t)*(e-h),a=(p-u)*(r-e)-(d-h)*(s-t);if(0===a)return;const g=l/a,m=c/a;return g>=0&&g<=1&&m>=0&&m<=1?(n.defined(f)||(f=new i.Cartesian2),f.x=e+g*(r-e),f.y=t+g*(s-t),f):void 0}},x=32767,C=x/2|0,y=[],v=[],B=[],b=new i.Cartographic;let A=new i.Cartesian3;const I=[],E=[],D=[],T=[],O=[],z=new i.Cartesian3,V=new t.BoundingSphere,M=new u.OrientedBoundingBox,N=new i.Cartesian2,k=new i.Cartesian3;function q(e,n){const o=e.isEastChild,d=e.isNorthChild,p=o?C:0,f=o?x:C,l=d?C:0,c=d?x:C,a=I,g=E,m=D,q=O;a.length=0,g.length=0,m.length=0,q.length=0;const R=T;R.length=0;const S={},U=e.vertices;let F=e.indices;F=F.subarray(0,e.indexCountWithoutSkirts);const P=r.TerrainEncoding.clone(e.encoding),W=P.hasVertexNormals;let K=0;const L=e.vertexCountWithoutSkirts,Y=e.minimumHeight,_=e.maximumHeight,j=new Array(L),G=new Array(L),J=new Array(L),Z=W?new Array(2*L):void 0,Q=20;let $,ee,te,ie,ne;for(ee=0,te=0;ee<L;++ee,te+=2){const e=P.decodeTextureCoordinates(U,ee,N);if($=P.decodeHeight(U,ee),ie=h.CesiumMath.clamp(e.x*x|0,0,x),ne=h.CesiumMath.clamp(e.y*x|0,0,x),J[ee]=h.CesiumMath.clamp(($-Y)/(_-Y)*x|0,0,x),ie<Q&&(ie=0),ne<Q&&(ne=0),x-ie<Q&&(ie=x),x-ne<Q&&(ne=x),j[ee]=ie,G[ee]=ne,W){const e=P.getOctEncodedNormal(U,ee,k);Z[te]=e.x,Z[te+1]=e.y}(o&&ie>=C||!o&&ie<=C)&&(d&&ne>=C||!d&&ne<=C)&&(S[ee]=K,a.push(ie),g.push(ne),m.push(J[ee]),W&&(q.push(Z[te]),q.push(Z[te+1])),++K)}const re=[];re.push(new H),re.push(new H),re.push(new H);const se=[];let oe,he;for(se.push(new H),se.push(new H),se.push(new H),ee=0;ee<F.length;ee+=3){const e=F[ee],t=F[ee+1],i=F[ee+2],n=j[e],r=j[t],s=j[i];re[0].initializeIndexed(j,G,J,Z,e),re[1].initializeIndexed(j,G,J,Z,t),re[2].initializeIndexed(j,G,J,Z,i);const h=w.clipTriangleAtAxisAlignedThreshold(C,o,n,r,s,y);oe=0,oe>=h.length||(oe=se[0].initializeFromClipResult(h,oe,re),oe>=h.length||(oe=se[1].initializeFromClipResult(h,oe,re),oe>=h.length||(oe=se[2].initializeFromClipResult(h,oe,re),he=w.clipTriangleAtAxisAlignedThreshold(C,d,se[0].getV(),se[1].getV(),se[2].getV(),v),X(a,g,m,q,R,S,he,se,W),oe<h.length&&(se[2].clone(se[1]),se[2].initializeFromClipResult(h,oe,re),he=w.clipTriangleAtAxisAlignedThreshold(C,d,se[0].getV(),se[1].getV(),se[2].getV(),v),X(a,g,m,q,R,S,he,se,W)))))}const ue=o?-x:0,de=d?-x:0,pe=[],fe=[],le=[],ce=[];let ae=Number.MAX_VALUE,ge=-ae;const me=B;me.length=0;const we=i.Ellipsoid.clone(e.ellipsoid),xe=i.Rectangle.clone(e.childRectangle),Ce=xe.north,ye=xe.south;let ve=xe.east;const Be=xe.west;for(ve<Be&&(ve+=h.CesiumMath.TWO_PI),ee=0;ee<a.length;++ee)ie=Math.round(a[ee]),ie<=p?(pe.push(ee),ie=0):ie>=f?(le.push(ee),ie=x):ie=2*ie+ue,a[ee]=ie,ne=Math.round(g[ee]),ne<=l?(fe.push(ee),ne=0):ne>=c?(ce.push(ee),ne=x):ne=2*ne+de,g[ee]=ne,$=h.CesiumMath.lerp(Y,_,m[ee]/x),$<ae&&(ae=$),$>ge&&(ge=$),m[ee]=$,b.longitude=h.CesiumMath.lerp(Be,ve,ie/x),b.latitude=h.CesiumMath.lerp(ye,Ce,ne/x),b.height=$,we.cartographicToCartesian(b,A),me.push(A.x),me.push(A.y),me.push(A.z);const be=t.BoundingSphere.fromVertices(me,i.Cartesian3.ZERO,3,V),Ae=u.OrientedBoundingBox.fromRectangle(xe,ae,ge,we,M),Ie=new r.EllipsoidalOccluder(we),Ee=Ie.computeHorizonCullingPointFromVerticesPossiblyUnderEllipsoid(be.center,me,3,be.center,ae,z),De=ge-ae,Te=new Uint16Array(a.length+g.length+m.length);for(ee=0;ee<a.length;++ee)Te[ee]=a[ee];let Oe=a.length;for(ee=0;ee<g.length;++ee)Te[Oe+ee]=g[ee];for(Oe+=g.length,ee=0;ee<m.length;++ee)Te[Oe+ee]=x*(m[ee]-ae)/De;const ze=s.IndexDatatype.createTypedArray(a.length,R);let Ve;if(W){const e=new Uint8Array(q);n.push(Te.buffer,ze.buffer,e.buffer),Ve=e.buffer}else n.push(Te.buffer,ze.buffer);return{vertices:Te.buffer,encodedNormals:Ve,indices:ze.buffer,minimumHeight:ae,maximumHeight:ge,westIndices:pe,southIndices:fe,eastIndices:le,northIndices:ce,boundingSphere:be,orientedBoundingBox:Ae,horizonOcclusionPoint:Ee}}function H(){this.vertexBuffer=void 0,this.index=void 0,this.first=void 0,this.second=void 0,this.ratio=void 0}H.prototype.clone=function(e){return n.defined(e)||(e=new H),e.uBuffer=this.uBuffer,e.vBuffer=this.vBuffer,e.heightBuffer=this.heightBuffer,e.normalBuffer=this.normalBuffer,e.index=this.index,e.first=this.first,e.second=this.second,e.ratio=this.ratio,e},H.prototype.initializeIndexed=function(e,t,i,n,r){this.uBuffer=e,this.vBuffer=t,this.heightBuffer=i,this.normalBuffer=n,this.index=r,this.first=void 0,this.second=void 0,this.ratio=void 0},H.prototype.initializeFromClipResult=function(e,t,i){let n=t+1;return-1!==e[t]?i[e[t]].clone(this):(this.vertexBuffer=void 0,this.index=void 0,this.first=i[e[n]],++n,this.second=i[e[n]],++n,this.ratio=e[n],++n),n},H.prototype.getKey=function(){return this.isIndexed()?this.index:JSON.stringify({first:this.first.getKey(),second:this.second.getKey(),ratio:this.ratio})},H.prototype.isIndexed=function(){return n.defined(this.index)},H.prototype.getH=function(){return n.defined(this.index)?this.heightBuffer[this.index]:h.CesiumMath.lerp(this.first.getH(),this.second.getH(),this.ratio)},H.prototype.getU=function(){return n.defined(this.index)?this.uBuffer[this.index]:h.CesiumMath.lerp(this.first.getU(),this.second.getU(),this.ratio)},H.prototype.getV=function(){return n.defined(this.index)?this.vBuffer[this.index]:h.CesiumMath.lerp(this.first.getV(),this.second.getV(),this.ratio)};let R=new i.Cartesian2,S=-1;const U=[new i.Cartesian3,new i.Cartesian3],F=[new i.Cartesian3,new i.Cartesian3];function P(t,n){++S;let r=U[S],s=F[S];return r=e.AttributeCompression.octDecode(t.first.getNormalX(),t.first.getNormalY(),r),s=e.AttributeCompression.octDecode(t.second.getNormalX(),t.second.getNormalY(),s),A=i.Cartesian3.lerp(r,s,t.ratio,A),i.Cartesian3.normalize(A,A),e.AttributeCompression.octEncode(A,n),--S,n}H.prototype.getNormalX=function(){return n.defined(this.index)?this.normalBuffer[2*this.index]:(R=P(this,R),R.x)},H.prototype.getNormalY=function(){return n.defined(this.index)?this.normalBuffer[2*this.index+1]:(R=P(this,R),R.y)};const W=[];function X(e,t,i,r,s,o,h,u,d){if(0===h.length)return;let p=0,f=0;while(f<h.length)f=W[p++].initializeFromClipResult(h,f,u);for(let l=0;l<p;++l){const s=W[l];if(s.isIndexed())s.newIndex=o[s.index],s.uBuffer=e,s.vBuffer=t,s.heightBuffer=i,d&&(s.normalBuffer=r);else{const h=s.getKey();if(n.defined(o[h]))s.newIndex=o[h];else{const n=e.length;e.push(s.getU()),t.push(s.getV()),i.push(s.getH()),d&&(r.push(s.getNormalX()),r.push(s.getNormalY())),s.newIndex=n,o[h]=n}}}3===p?(s.push(W[0].newIndex),s.push(W[1].newIndex),s.push(W[2].newIndex)):4===p&&(s.push(W[0].newIndex),s.push(W[1].newIndex),s.push(W[2].newIndex),s.push(W[0].newIndex),s.push(W[2].newIndex),s.push(W[3].newIndex))}W.push(new H),W.push(new H),W.push(new H),W.push(new H);var K=d(q);return K}));