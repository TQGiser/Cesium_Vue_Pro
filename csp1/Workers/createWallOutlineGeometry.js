define(["./defaultValue-94c3e563","./Matrix2-fc7e9822","./Transforms-a076dbe6","./ComponentDatatype-4a60b8d6","./RuntimeError-c581ca93","./GeometryAttribute-2ecf73f6","./GeometryAttributes-7df9bef6","./IndexDatatype-db156785","./WallGeometryLibrary-9abfba7e","./_commonjsHelpers-3aae1032-f55dc0c4","./combine-761d9c3f","./WebGLConstants-7dccdc96","./arrayRemoveDuplicates-06991c15","./PolylinePipeline-7608e667","./EllipsoidGeodesic-dc94f381","./EllipsoidRhumbLine-daebc75b","./IntersectionTests-5deed78b","./Plane-e20fba8c"],(function(e,i,t,n,o,r,s,a,l,d,m,u,p,c,f,h,g,y){"use strict";const E=new i.Cartesian3,_=new i.Cartesian3;function w(t){t=e.defaultValue(t,e.defaultValue.EMPTY_OBJECT);const r=t.positions,s=t.maximumHeights,a=t.minimumHeights;if(!e.defined(r))throw new o.DeveloperError("options.positions is required.");if(e.defined(s)&&s.length!==r.length)throw new o.DeveloperError("options.positions and options.maximumHeights must have the same length.");if(e.defined(a)&&a.length!==r.length)throw new o.DeveloperError("options.positions and options.minimumHeights must have the same length.");const l=e.defaultValue(t.granularity,n.CesiumMath.RADIANS_PER_DEGREE),d=e.defaultValue(t.ellipsoid,i.Ellipsoid.WGS84);this._positions=r,this._minimumHeights=a,this._maximumHeights=s,this._granularity=l,this._ellipsoid=i.Ellipsoid.clone(d),this._workerName="createWallOutlineGeometry";let m=1+r.length*i.Cartesian3.packedLength+2;e.defined(a)&&(m+=a.length),e.defined(s)&&(m+=s.length),this.packedLength=m+i.Ellipsoid.packedLength+1}w.pack=function(t,n,r){if(!e.defined(t))throw new o.DeveloperError("value is required");if(!e.defined(n))throw new o.DeveloperError("array is required");let s;r=e.defaultValue(r,0);const a=t._positions;let l=a.length;for(n[r++]=l,s=0;s<l;++s,r+=i.Cartesian3.packedLength)i.Cartesian3.pack(a[s],n,r);const d=t._minimumHeights;if(l=e.defined(d)?d.length:0,n[r++]=l,e.defined(d))for(s=0;s<l;++s)n[r++]=d[s];const m=t._maximumHeights;if(l=e.defined(m)?m.length:0,n[r++]=l,e.defined(m))for(s=0;s<l;++s)n[r++]=m[s];return i.Ellipsoid.pack(t._ellipsoid,n,r),r+=i.Ellipsoid.packedLength,n[r]=t._granularity,n};const b=i.Ellipsoid.clone(i.Ellipsoid.UNIT_SPHERE),H={positions:void 0,minimumHeights:void 0,maximumHeights:void 0,ellipsoid:b,granularity:void 0};function v(t,n){return e.defined(n)&&(t=w.unpack(t,n)),t._ellipsoid=i.Ellipsoid.clone(t._ellipsoid),w.createGeometry(t)}return w.unpack=function(t,n,r){if(!e.defined(t))throw new o.DeveloperError("array is required");let s;n=e.defaultValue(n,0);let a=t[n++];const l=new Array(a);for(s=0;s<a;++s,n+=i.Cartesian3.packedLength)l[s]=i.Cartesian3.unpack(t,n);let d,m;if(a=t[n++],a>0)for(d=new Array(a),s=0;s<a;++s)d[s]=t[n++];if(a=t[n++],a>0)for(m=new Array(a),s=0;s<a;++s)m[s]=t[n++];const u=i.Ellipsoid.unpack(t,n,b);n+=i.Ellipsoid.packedLength;const p=t[n];return e.defined(r)?(r._positions=l,r._minimumHeights=d,r._maximumHeights=m,r._ellipsoid=i.Ellipsoid.clone(u,r._ellipsoid),r._granularity=p,r):(H.positions=l,H.minimumHeights=d,H.maximumHeights=m,H.granularity=p,new w(H))},w.fromConstantHeights=function(i){i=e.defaultValue(i,e.defaultValue.EMPTY_OBJECT);const t=i.positions;if(!e.defined(t))throw new o.DeveloperError("options.positions is required.");let n,r;const s=i.minimumHeight,a=i.maximumHeight,l=e.defined(s),d=e.defined(a);if(l||d){const e=t.length;n=l?new Array(e):void 0,r=d?new Array(e):void 0;for(let i=0;i<e;++i)l&&(n[i]=s),d&&(r[i]=a)}const m={positions:t,maximumHeights:r,minimumHeights:n,ellipsoid:i.ellipsoid};return new w(m)},w.createGeometry=function(o){const d=o._positions,m=o._minimumHeights,u=o._maximumHeights,p=o._granularity,c=o._ellipsoid,f=l.WallGeometryLibrary.computePositions(c,d,u,m,p,!1);if(!e.defined(f))return;const h=f.bottomPositions,g=f.topPositions;let y=g.length,w=2*y;const b=new Float64Array(w);let H,v=0;for(y/=3,H=0;H<y;++H){const e=3*H,t=i.Cartesian3.fromArray(g,e,E),n=i.Cartesian3.fromArray(h,e,_);b[v++]=n.x,b[v++]=n.y,b[v++]=n.z,b[v++]=t.x,b[v++]=t.y,b[v++]=t.z}const C=new s.GeometryAttributes({position:new r.GeometryAttribute({componentDatatype:n.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:b})}),A=w/3;w=2*A-4+A;const D=a.IndexDatatype.createTypedArray(A,w);let k=0;for(H=0;H<A-2;H+=2){const e=H,t=H+2,o=i.Cartesian3.fromArray(b,3*e,E),r=i.Cartesian3.fromArray(b,3*t,_);if(i.Cartesian3.equalsEpsilon(o,r,n.CesiumMath.EPSILON10))continue;const s=H+1,a=H+3;D[k++]=s,D[k++]=e,D[k++]=s,D[k++]=a,D[k++]=e,D[k++]=t}return D[k++]=A-2,D[k++]=A-1,new r.Geometry({attributes:C,indices:D,primitiveType:r.PrimitiveType.LINES,boundingSphere:new t.BoundingSphere.fromVertices(b)})},v}));