define(["./Transforms-a076dbe6","./Matrix2-fc7e9822","./RuntimeError-c581ca93","./defaultValue-94c3e563","./ComponentDatatype-4a60b8d6","./ArcType-0cf52f8c","./arrayRemoveDuplicates-06991c15","./EllipsoidGeodesic-dc94f381","./EllipsoidRhumbLine-daebc75b","./EncodedCartesian3-d3e254ea","./GeometryAttribute-2ecf73f6","./IntersectionTests-5deed78b","./Plane-e20fba8c","./WebMercatorProjection-843df830","./_commonjsHelpers-3aae1032-f55dc0c4","./combine-761d9c3f","./WebGLConstants-7dccdc96"],(function(e,t,a,n,i,r,s,o,l,c,u,C,d,p,h,g,f){"use strict";function m(a){a=n.defaultValue(a,n.defaultValue.EMPTY_OBJECT),this._ellipsoid=n.defaultValue(a.ellipsoid,t.Ellipsoid.WGS84),this._rectangle=n.defaultValue(a.rectangle,t.Rectangle.MAX_VALUE),this._projection=new e.GeographicProjection(this._ellipsoid),this._numberOfLevelZeroTilesX=n.defaultValue(a.numberOfLevelZeroTilesX,2),this._numberOfLevelZeroTilesY=n.defaultValue(a.numberOfLevelZeroTilesY,1)}Object.defineProperties(m.prototype,{ellipsoid:{get:function(){return this._ellipsoid}},rectangle:{get:function(){return this._rectangle}},projection:{get:function(){return this._projection}}}),m.prototype.getNumberOfXTilesAtLevel=function(e){return this._numberOfLevelZeroTilesX<<e},m.prototype.getNumberOfYTilesAtLevel=function(e){return this._numberOfLevelZeroTilesY<<e},m.prototype.rectangleToNativeRectangle=function(e,r){a.Check.defined("rectangle",e);const s=i.CesiumMath.toDegrees(e.west),o=i.CesiumMath.toDegrees(e.south),l=i.CesiumMath.toDegrees(e.east),c=i.CesiumMath.toDegrees(e.north);return n.defined(r)?(r.west=s,r.south=o,r.east=l,r.north=c,r):new t.Rectangle(s,o,l,c)},m.prototype.tileXYToNativeRectangle=function(e,t,a,n){const r=this.tileXYToRectangle(e,t,a,n);return r.west=i.CesiumMath.toDegrees(r.west),r.south=i.CesiumMath.toDegrees(r.south),r.east=i.CesiumMath.toDegrees(r.east),r.north=i.CesiumMath.toDegrees(r.north),r},m.prototype.tileXYToRectangle=function(e,a,i,r){const s=this._rectangle,o=this.getNumberOfXTilesAtLevel(i),l=this.getNumberOfYTilesAtLevel(i),c=s.width/o,u=e*c+s.west,C=(e+1)*c+s.west,d=s.height/l,p=s.north-a*d,h=s.north-(a+1)*d;return n.defined(r)||(r=new t.Rectangle(u,h,C,p)),r.west=u,r.south=h,r.east=C,r.north=p,r},m.prototype.positionToTileXY=function(e,a,r){const s=this._rectangle;if(!t.Rectangle.contains(s,e))return;const o=this.getNumberOfXTilesAtLevel(a),l=this.getNumberOfYTilesAtLevel(a),c=s.width/o,u=s.height/l;let C=e.longitude;s.east<s.west&&(C+=i.CesiumMath.TWO_PI);let d=(C-s.west)/c|0;d>=o&&(d=o-1);let p=(s.north-e.latitude)/u|0;return p>=l&&(p=l-1),n.defined(r)?(r.x=d,r.y=p,r):new t.Cartesian2(d,p)};const w=new t.Cartesian3,y=new t.Cartesian3,T=new t.Cartographic,E=new t.Cartesian3,M=new t.Cartesian3,_=new e.BoundingSphere,O=new m,b=[new t.Cartographic,new t.Cartographic,new t.Cartographic,new t.Cartographic],A=new t.Cartesian2,k={};function P(e){t.Cartographic.fromRadians(e.east,e.north,0,b[0]),t.Cartographic.fromRadians(e.west,e.north,0,b[1]),t.Cartographic.fromRadians(e.east,e.south,0,b[2]),t.Cartographic.fromRadians(e.west,e.south,0,b[3]);let a=0,n=0,i=0,r=0;const s=k._terrainHeightsMaxLevel;let o;for(o=0;o<=s;++o){let e=!1;for(let t=0;t<4;++t){const a=b[t];if(O.positionToTileXY(a,o,A),0===t)i=A.x,r=A.y;else if(i!==A.x||r!==A.y){e=!0;break}}if(e)break;a=i,n=r}if(0!==o)return{x:a,y:n,level:o>s?s:o-1}}k.initialize=function(){let t=k._initPromise;return n.defined(t)||(t=e.Resource.fetchJson(e.buildModuleUrl("Assets/approximateTerrainHeights.json")).then((function(e){k._terrainHeights=e})),k._initPromise=t),t},k.getMinimumMaximumHeights=function(e,i){if(a.Check.defined("rectangle",e),!n.defined(k._terrainHeights))throw new a.DeveloperError("You must call ApproximateTerrainHeights.initialize and wait for the promise to resolve before using this function");i=n.defaultValue(i,t.Ellipsoid.WGS84);const r=P(e);let s=k._defaultMinTerrainHeight,o=k._defaultMaxTerrainHeight;if(n.defined(r)){const a=`${r.level}-${r.x}-${r.y}`,l=k._terrainHeights[a];n.defined(l)&&(s=l[0],o=l[1]),i.cartographicToCartesian(t.Rectangle.northeast(e,T),w),i.cartographicToCartesian(t.Rectangle.southwest(e,T),y),t.Cartesian3.midpoint(y,w,E);const c=i.scaleToGeodeticSurface(E,M);if(n.defined(c)){const e=t.Cartesian3.distance(E,c);s=Math.min(s,-e)}else s=k._defaultMinTerrainHeight}return s=Math.max(k._defaultMinTerrainHeight,s),{minimumTerrainHeight:s,maximumTerrainHeight:o}},k.getBoundingSphere=function(i,r){if(a.Check.defined("rectangle",i),!n.defined(k._terrainHeights))throw new a.DeveloperError("You must call ApproximateTerrainHeights.initialize and wait for the promise to resolve before using this function");r=n.defaultValue(r,t.Ellipsoid.WGS84);const s=P(i);let o=k._defaultMaxTerrainHeight;if(n.defined(s)){const e=`${s.level}-${s.x}-${s.y}`,t=k._terrainHeights[e];n.defined(t)&&(o=t[1])}const l=e.BoundingSphere.fromRectangle3D(i,r,0);return e.BoundingSphere.fromRectangle3D(i,r,o,_),e.BoundingSphere.union(l,_,l)},k._terrainHeightsMaxLevel=6,k._defaultMaxTerrainHeight=9e3,k._defaultMinTerrainHeight=-1e5,k._terrainHeights=void 0,k._initPromise=void 0,Object.defineProperties(k,{initialized:{get:function(){return n.defined(k._terrainHeights)}}});const S=[e.GeographicProjection,p.WebMercatorProjection],L=S.length,x=Math.cos(i.CesiumMath.toRadians(30)),I=Math.cos(i.CesiumMath.toRadians(150)),D=0,N=1e3;function R(e){e=n.defaultValue(e,n.defaultValue.EMPTY_OBJECT);const i=e.positions;if(!n.defined(i)||i.length<2)throw new a.DeveloperError("At least two positions are required.");if(n.defined(e.arcType)&&e.arcType!==r.ArcType.GEODESIC&&e.arcType!==r.ArcType.RHUMB)throw new a.DeveloperError("Valid options for arcType are ArcType.GEODESIC and ArcType.RHUMB.");this.width=n.defaultValue(e.width,1),this._positions=i,this.granularity=n.defaultValue(e.granularity,9999),this.loop=n.defaultValue(e.loop,!1),this.arcType=n.defaultValue(e.arcType,r.ArcType.GEODESIC),this._ellipsoid=t.Ellipsoid.WGS84,this._projectionIndex=0,this._workerName="createGroundPolylineGeometry",this._scene3DOnly=!1}Object.defineProperties(R.prototype,{packedLength:{get:function(){return 1+3*this._positions.length+1+1+1+t.Ellipsoid.packedLength+1+1}}}),R.setProjectionAndEllipsoid=function(e,t){let a=0;for(let n=0;n<L;n++)if(t instanceof S[n]){a=n;break}e._projectionIndex=a,e._ellipsoid=t.ellipsoid};const v=new t.Cartesian3,H=new t.Cartesian3,z=new t.Cartesian3;function B(e,a,n,i,r){const s=X(i,e,0,v),o=X(i,e,n,H),l=X(i,a,0,z),c=U(o,s,H),u=U(l,s,z);return t.Cartesian3.cross(u,c,r),t.Cartesian3.normalize(r,r)}const j=new t.Cartographic,G=new t.Cartesian3,V=new t.Cartesian3,Y=new t.Cartesian3;function q(e,a,n,i,s,c,u,C,d,p,h){if(0===s)return;let g;c===r.ArcType.GEODESIC?g=new o.EllipsoidGeodesic(e,a,u):c===r.ArcType.RHUMB&&(g=new l.EllipsoidRhumbLine(e,a,u));const f=g.surfaceDistance;if(f<s)return;const m=B(e,a,i,u,Y),w=Math.ceil(f/s),y=f/w;let T=y;const E=w-1;let M=C.length;for(let r=0;r<E;r++){const e=g.interpolateUsingSurfaceDistance(T,j),a=X(u,e,n,G),r=X(u,e,i,V);t.Cartesian3.pack(m,C,M),t.Cartesian3.pack(a,d,M),t.Cartesian3.pack(r,p,M),h.push(e.latitude),h.push(e.longitude),M+=3,T+=y}}const F=new t.Cartographic;function X(e,a,n,i){return t.Cartographic.clone(a,F),F.height=n,t.Cartographic.toCartesian(F,e,i)}function U(e,a,n){return t.Cartesian3.subtract(e,a,n),t.Cartesian3.normalize(n,n),n}function W(e,a,n,i){return i=U(e,a,i),i=t.Cartesian3.cross(i,n,i),i=t.Cartesian3.normalize(i,i),i=t.Cartesian3.cross(n,i,i),i}R.pack=function(e,i,r){a.Check.typeOf.object("value",e),a.Check.defined("array",i);let s=n.defaultValue(r,0);const o=e._positions,l=o.length;i[s++]=l;for(let a=0;a<l;++a){const e=o[a];t.Cartesian3.pack(e,i,s),s+=3}return i[s++]=e.granularity,i[s++]=e.loop?1:0,i[s++]=e.arcType,t.Ellipsoid.pack(e._ellipsoid,i,s),s+=t.Ellipsoid.packedLength,i[s++]=e._projectionIndex,i[s++]=e._scene3DOnly?1:0,i},R.unpack=function(e,i,r){a.Check.defined("array",e);let s=n.defaultValue(i,0);const o=e[s++],l=new Array(o);for(let a=0;a<o;a++)l[a]=t.Cartesian3.unpack(e,s),s+=3;const c=e[s++],u=1===e[s++],C=e[s++],d=t.Ellipsoid.unpack(e,s);s+=t.Ellipsoid.packedLength;const p=e[s++],h=1===e[s++];return n.defined(r)||(r=new R({positions:l})),r._positions=l,r.granularity=c,r.loop=u,r.arcType=C,r._ellipsoid=d,r._projectionIndex=p,r._scene3DOnly=h,r};const Z=new t.Cartesian3,$=new t.Cartesian3,J=new t.Cartesian3,Q=new t.Cartesian3,K=0,ee=-1;function te(e,a,n,r,s){const o=U(n,a,Q),l=W(e,a,o,Z),c=W(r,a,o,$);if(i.CesiumMath.equalsEpsilon(t.Cartesian3.dot(l,c),ee,i.CesiumMath.EPSILON5))return s=t.Cartesian3.cross(o,l,s),s=t.Cartesian3.normalize(s,s),s;s=t.Cartesian3.add(c,l,s),s=t.Cartesian3.normalize(s,s);const u=t.Cartesian3.cross(o,s,J);return t.Cartesian3.dot(c,u)<K&&(s=t.Cartesian3.negate(s,s)),s}const ae=d.Plane.fromPointNormal(t.Cartesian3.ZERO,t.Cartesian3.UNIT_Y),ne=new t.Cartesian3,ie=new t.Cartesian3,re=new t.Cartesian3,se=new t.Cartesian3,oe=new t.Cartesian3,le=new t.Cartesian3,ce=new t.Cartographic,ue=new t.Cartographic,Ce=new t.Cartographic;R.createGeometry=function(e){const a=!e._scene3DOnly;let o=e.loop;const c=e._ellipsoid,u=e.granularity,d=e.arcType,p=new S[e._projectionIndex](c),h=D,g=N;let f,m;const w=e._positions,y=w.length;let T,E,M,_;2===y&&(o=!1);const O=new l.EllipsoidRhumbLine(void 0,void 0,c);let b,A,k;const P=[w[0]];for(m=0;m<y-1;m++)T=w[m],E=w[m+1],b=C.IntersectionTests.lineSegmentPlane(T,E,ae,le),!n.defined(b)||t.Cartesian3.equalsEpsilon(b,T,i.CesiumMath.EPSILON7)||t.Cartesian3.equalsEpsilon(b,E,i.CesiumMath.EPSILON7)||(e.arcType===r.ArcType.GEODESIC?P.push(t.Cartesian3.clone(b)):e.arcType===r.ArcType.RHUMB&&(k=c.cartesianToCartographic(b,ce).longitude,M=c.cartesianToCartographic(T,ce),_=c.cartesianToCartographic(E,ue),O.setEndPoints(M,_),A=O.findIntersectionWithLongitude(k,Ce),b=c.cartographicToCartesian(A,le),!n.defined(b)||t.Cartesian3.equalsEpsilon(b,T,i.CesiumMath.EPSILON7)||t.Cartesian3.equalsEpsilon(b,E,i.CesiumMath.EPSILON7)||P.push(t.Cartesian3.clone(b)))),P.push(E);o&&(T=w[y-1],E=w[0],b=C.IntersectionTests.lineSegmentPlane(T,E,ae,le),!n.defined(b)||t.Cartesian3.equalsEpsilon(b,T,i.CesiumMath.EPSILON7)||t.Cartesian3.equalsEpsilon(b,E,i.CesiumMath.EPSILON7)||(e.arcType===r.ArcType.GEODESIC?P.push(t.Cartesian3.clone(b)):e.arcType===r.ArcType.RHUMB&&(k=c.cartesianToCartographic(b,ce).longitude,M=c.cartesianToCartographic(T,ce),_=c.cartesianToCartographic(E,ue),O.setEndPoints(M,_),A=O.findIntersectionWithLongitude(k,Ce),b=c.cartographicToCartesian(A,le),!n.defined(b)||t.Cartesian3.equalsEpsilon(b,T,i.CesiumMath.EPSILON7)||t.Cartesian3.equalsEpsilon(b,E,i.CesiumMath.EPSILON7)||P.push(t.Cartesian3.clone(b)))));let L=P.length,x=new Array(L);for(m=0;m<L;m++){const e=t.Cartographic.fromCartesian(P[m],c);e.height=0,x[m]=e}if(x=s.arrayRemoveDuplicates(x,t.Cartographic.equalsEpsilon),L=x.length,L<2)return;const I=[],R=[],v=[],H=[];let z=ne,j=ie,G=re,V=se,Y=oe;const F=x[0],U=x[1],W=x[L-1];for(z=X(c,W,h,z),V=X(c,U,h,V),j=X(c,F,h,j),G=X(c,F,g,G),Y=o?te(z,j,G,V,Y):B(F,U,g,c,Y),t.Cartesian3.pack(Y,R,0),t.Cartesian3.pack(j,v,0),t.Cartesian3.pack(G,H,0),I.push(F.latitude),I.push(F.longitude),q(F,U,h,g,u,d,c,R,v,H,I),m=1;m<L-1;++m){z=t.Cartesian3.clone(j,z),j=t.Cartesian3.clone(V,j);const e=x[m];X(c,e,g,G),X(c,x[m+1],h,V),te(z,j,G,V,Y),f=R.length,t.Cartesian3.pack(Y,R,f),t.Cartesian3.pack(j,v,f),t.Cartesian3.pack(G,H,f),I.push(e.latitude),I.push(e.longitude),q(x[m],x[m+1],h,g,u,d,c,R,v,H,I)}const Z=x[L-1],$=x[L-2];if(j=X(c,Z,h,j),G=X(c,Z,g,G),o){const e=x[0];z=X(c,$,h,z),V=X(c,e,h,V),Y=te(z,j,G,V,Y)}else Y=B($,Z,g,c,Y);if(f=R.length,t.Cartesian3.pack(Y,R,f),t.Cartesian3.pack(j,v,f),t.Cartesian3.pack(G,H,f),I.push(Z.latitude),I.push(Z.longitude),o){for(q(Z,F,h,g,u,d,c,R,v,H,I),f=R.length,m=0;m<3;++m)R[f+m]=R[m],v[f+m]=v[m],H[f+m]=H[m];I.push(F.latitude),I.push(F.longitude)}return it(o,p,v,H,R,I,a)};const de=new t.Cartesian3,pe=new t.Matrix3,he=new e.Quaternion;function ge(a,n,r,s){const o=U(r,n,de),l=t.Cartesian3.dot(o,a);if(l>x||l<I){const n=U(s,r,Q),o=l<I?i.CesiumMath.PI_OVER_TWO:-i.CesiumMath.PI_OVER_TWO,c=e.Quaternion.fromAxisAngle(n,o,he),u=t.Matrix3.fromQuaternion(c,pe);return t.Matrix3.multiplyByVector(u,a,a),!0}return!1}const fe=new t.Cartographic,me=new t.Cartesian3,we=new t.Cartesian3;function ye(e,a,n,r,s){const o=t.Cartographic.toCartesian(a,e._ellipsoid,me);let l=t.Cartesian3.add(o,n,we),c=!1;const u=e._ellipsoid;let C=u.cartesianToCartographic(l,fe);Math.abs(a.longitude-C.longitude)>i.CesiumMath.PI_OVER_TWO&&(c=!0,l=t.Cartesian3.subtract(o,n,we),C=u.cartesianToCartographic(l,fe)),C.height=0;const d=e.project(C,s);return s=t.Cartesian3.subtract(d,r,s),s.z=0,s=t.Cartesian3.normalize(s,s),c&&t.Cartesian3.negate(s,s),s}const Te=new t.Cartesian3,Ee=new t.Cartesian3;function Me(e,a,n,i,r,s){const o=t.Cartesian3.subtract(a,e,Te);t.Cartesian3.normalize(o,o);const l=n-D;let c=t.Cartesian3.multiplyByScalar(o,l,Ee);t.Cartesian3.add(e,c,r);const u=i-N;c=t.Cartesian3.multiplyByScalar(o,u,Ee),t.Cartesian3.add(a,c,s)}const _e=new t.Cartesian3;function Oe(e,a){const n=d.Plane.getPointDistance(ae,e),r=d.Plane.getPointDistance(ae,a);let s=_e;i.CesiumMath.equalsEpsilon(n,0,i.CesiumMath.EPSILON2)?(s=U(a,e,s),t.Cartesian3.multiplyByScalar(s,i.CesiumMath.EPSILON2,s),t.Cartesian3.add(e,s,e)):i.CesiumMath.equalsEpsilon(r,0,i.CesiumMath.EPSILON2)&&(s=U(e,a,s),t.Cartesian3.multiplyByScalar(s,i.CesiumMath.EPSILON2,s),t.Cartesian3.add(a,s,a))}function be(e,t){const a=Math.abs(e.longitude),n=Math.abs(t.longitude);if(i.CesiumMath.equalsEpsilon(a,i.CesiumMath.PI,i.CesiumMath.EPSILON11)){const n=i.CesiumMath.sign(t.longitude);return e.longitude=n*(a-i.CesiumMath.EPSILON11),1}if(i.CesiumMath.equalsEpsilon(n,i.CesiumMath.PI,i.CesiumMath.EPSILON11)){const a=i.CesiumMath.sign(e.longitude);return t.longitude=a*(n-i.CesiumMath.EPSILON11),2}return 0}const Ae=new t.Cartographic,ke=new t.Cartographic,Pe=new t.Cartesian3,Se=new t.Cartesian3,Le=new t.Cartesian3,xe=new t.Cartesian3,Ie=new t.Cartesian3,De=new t.Cartesian3,Ne=[Ae,ke],Re=new t.Rectangle,ve=new t.Cartesian3,He=new t.Cartesian3,ze=new t.Cartesian3,Be=new t.Cartesian3,je=new t.Cartesian3,Ge=new t.Cartesian3,Ve=new t.Cartesian3,Ye=new t.Cartesian3,qe=new t.Cartesian3,Fe=new t.Cartesian3,Xe=new t.Cartesian3,Ue=new t.Cartesian3,We=new t.Cartesian3,Ze=new t.Cartesian3,$e=new c.EncodedCartesian3,Je=new c.EncodedCartesian3,Qe=new t.Cartesian3,Ke=new t.Cartesian3,et=new t.Cartesian3,tt=[new e.BoundingSphere,new e.BoundingSphere],at=[0,2,1,0,3,2,0,7,3,0,4,7,0,5,4,0,1,5,5,7,4,5,6,7,5,2,6,5,1,2,3,6,2,3,7,6],nt=at.length;function it(a,n,r,s,o,l,C){let d,p;const h=n._ellipsoid,g=r.length/3-1,f=8*g,m=4*f,w=36*g,y=f>65535?new Uint32Array(w):new Uint16Array(w),T=new Float64Array(3*f),E=new Float32Array(m),M=new Float32Array(m),_=new Float32Array(m),O=new Float32Array(m),b=new Float32Array(m);let A,P,S,L;C&&(A=new Float32Array(m),P=new Float32Array(m),S=new Float32Array(m),L=new Float32Array(2*f));const I=l.length/2;let D=0;const N=Ae;N.height=0;const R=ke;R.height=0;let v=Pe,H=Se;if(C)for(p=0,d=1;d<I;d++)N.latitude=l[p],N.longitude=l[p+1],R.latitude=l[p+2],R.longitude=l[p+3],v=n.project(N,v),H=n.project(R,H),D+=t.Cartesian3.distance(v,H),p+=2;const z=s.length/3;H=t.Cartesian3.unpack(s,0,H);let B,j=0;for(p=3,d=1;d<z;d++)v=t.Cartesian3.clone(H,v),H=t.Cartesian3.unpack(s,p,H),j+=t.Cartesian3.distance(v,H),p+=3;p=3;let G=0,V=0,Y=0,q=0,F=!1,X=t.Cartesian3.unpack(r,0,xe),W=t.Cartesian3.unpack(s,0,Se),Z=t.Cartesian3.unpack(o,0,De);if(a){const e=t.Cartesian3.unpack(r,r.length-6,Le);ge(Z,e,X,W)&&(Z=t.Cartesian3.negate(Z,Z))}let $=0,J=0,Q=0;for(d=0;d<g;d++){const e=t.Cartesian3.clone(X,Le),a=t.Cartesian3.clone(W,Pe);let u,d,g,f,m=t.Cartesian3.clone(Z,Ie);if(F&&(m=t.Cartesian3.negate(m,m)),X=t.Cartesian3.unpack(r,p,xe),W=t.Cartesian3.unpack(s,p,Se),Z=t.Cartesian3.unpack(o,p,De),F=ge(Z,e,X,W),N.latitude=l[G],N.longitude=l[G+1],R.latitude=l[G+2],R.longitude=l[G+3],C){const e=be(N,R);u=n.project(N,je),d=n.project(R,Ge);const a=U(d,u,Qe);a.y=Math.abs(a.y),g=Ve,f=Ye,0===e||t.Cartesian3.dot(a,t.Cartesian3.UNIT_Y)>x?(g=ye(n,N,m,u,Ve),f=ye(n,R,Z,d,Ye)):1===e?(f=ye(n,R,Z,d,Ye),g.x=0,g.y=i.CesiumMath.sign(N.longitude-Math.abs(R.longitude)),g.z=0):(g=ye(n,N,m,u,Ve),f.x=0,f.y=i.CesiumMath.sign(N.longitude-R.longitude),f.z=0)}const w=t.Cartesian3.distance(a,W),y=c.EncodedCartesian3.fromCartesian(e,$e),I=t.Cartesian3.subtract(X,e,qe),v=t.Cartesian3.normalize(I,Ue);let H=t.Cartesian3.subtract(a,e,Fe);H=t.Cartesian3.normalize(H,H);let z=t.Cartesian3.cross(v,H,Ue);z=t.Cartesian3.normalize(z,z);let K=t.Cartesian3.cross(H,m,We);K=t.Cartesian3.normalize(K,K);let ee=t.Cartesian3.subtract(W,X,Xe);ee=t.Cartesian3.normalize(ee,ee);let te=t.Cartesian3.cross(Z,ee,Ze);te=t.Cartesian3.normalize(te,te);const ae=w/j,ne=$/j;let ie,re,se,oe=0,le=0,ce=0;if(C){oe=t.Cartesian3.distance(u,d),ie=c.EncodedCartesian3.fromCartesian(u,Je),re=t.Cartesian3.subtract(d,u,Qe),se=t.Cartesian3.normalize(re,Ke);const e=se.x;se.x=se.y,se.y=-e,le=oe/D,ce=J/D}for(B=0;B<8;B++){const e=q+4*B,a=V+2*B,n=e+3,i=B<4?1:-1,r=2===B||3===B||6===B||7===B?1:-1;t.Cartesian3.pack(y.high,E,e),E[n]=I.x,t.Cartesian3.pack(y.low,M,e),M[n]=I.y,t.Cartesian3.pack(K,_,e),_[n]=I.z,t.Cartesian3.pack(te,O,e),O[n]=ae*i,t.Cartesian3.pack(z,b,e);let s=ne*r;0===s&&r<0&&(s=9),b[n]=s,C&&(A[e]=ie.high.x,A[e+1]=ie.high.y,A[e+2]=ie.low.x,A[e+3]=ie.low.y,S[e]=-g.y,S[e+1]=g.x,S[e+2]=f.y,S[e+3]=-f.x,P[e]=re.x,P[e+1]=re.y,P[e+2]=se.x,P[e+3]=se.y,L[a]=le*i,s=ce*r,0===s&&r<0&&(s=9),L[a+1]=s)}const ue=ze,Ce=Be,de=ve,pe=He,he=t.Rectangle.fromCartographicArray(Ne,Re),fe=k.getMinimumMaximumHeights(he,h),me=fe.minimumTerrainHeight,we=fe.maximumTerrainHeight;Q+=me,Q+=we,Me(e,a,me,we,ue,de),Me(X,W,me,we,Ce,pe);let Te=t.Cartesian3.multiplyByScalar(z,i.CesiumMath.EPSILON5,et);t.Cartesian3.add(ue,Te,ue),t.Cartesian3.add(Ce,Te,Ce),t.Cartesian3.add(de,Te,de),t.Cartesian3.add(pe,Te,pe),Oe(ue,Ce),Oe(de,pe),t.Cartesian3.pack(ue,T,Y),t.Cartesian3.pack(Ce,T,Y+3),t.Cartesian3.pack(pe,T,Y+6),t.Cartesian3.pack(de,T,Y+9),Te=t.Cartesian3.multiplyByScalar(z,-2*i.CesiumMath.EPSILON5,et),t.Cartesian3.add(ue,Te,ue),t.Cartesian3.add(Ce,Te,Ce),t.Cartesian3.add(de,Te,de),t.Cartesian3.add(pe,Te,pe),Oe(ue,Ce),Oe(de,pe),t.Cartesian3.pack(ue,T,Y+12),t.Cartesian3.pack(Ce,T,Y+15),t.Cartesian3.pack(pe,T,Y+18),t.Cartesian3.pack(de,T,Y+21),G+=2,p+=3,V+=16,Y+=24,q+=32,$+=w,J+=oe}p=0;let K=0;for(d=0;d<g;d++){for(B=0;B<nt;B++)y[p+B]=at[B]+K;K+=8,p+=nt}const ee=tt;e.BoundingSphere.fromVertices(r,t.Cartesian3.ZERO,3,ee[0]),e.BoundingSphere.fromVertices(s,t.Cartesian3.ZERO,3,ee[1]);const te=e.BoundingSphere.fromBoundingSpheres(ee);te.radius+=Q/(2*g);const ae={position:new u.GeometryAttribute({componentDatatype:i.ComponentDatatype.DOUBLE,componentsPerAttribute:3,normalize:!1,values:T}),startHiAndForwardOffsetX:rt(E),startLoAndForwardOffsetY:rt(M),startNormalAndForwardOffsetZ:rt(_),endNormalAndTextureCoordinateNormalizationX:rt(O),rightNormalAndTextureCoordinateNormalizationY:rt(b)};return C&&(ae.startHiLo2D=rt(A),ae.offsetAndRight2D=rt(P),ae.startEndNormals2D=rt(S),ae.texcoordNormalization2D=new u.GeometryAttribute({componentDatatype:i.ComponentDatatype.FLOAT,componentsPerAttribute:2,normalize:!1,values:L})),new u.Geometry({attributes:ae,indices:y,boundingSphere:te})}function rt(e){return new u.GeometryAttribute({componentDatatype:i.ComponentDatatype.FLOAT,componentsPerAttribute:4,normalize:!1,values:e})}function st(e,t){return k.initialize().then((function(){return n.defined(t)&&(e=R.unpack(e,t)),R.createGeometry(e)}))}return R._projectNormal=ye,st}));