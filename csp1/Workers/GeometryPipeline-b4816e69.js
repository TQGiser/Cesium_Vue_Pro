define(["exports","./AttributeCompression-4d18cc04","./Matrix2-fc7e9822","./RuntimeError-c581ca93","./defaultValue-94c3e563","./ComponentDatatype-4a60b8d6","./Transforms-a076dbe6","./EncodedCartesian3-d3e254ea","./GeometryAttribute-2ecf73f6","./IndexDatatype-db156785","./IntersectionTests-5deed78b","./Plane-e20fba8c"],(function(e,t,r,n,i,a,o,s,u,l,p,c){"use strict";const d=new r.Cartesian3,f=new r.Cartesian3,m=new r.Cartesian3;function y(e,t,o,s,u){let l,p,c,y,h,v,C,b;if(n.Check.defined("point",e),n.Check.defined("p0",t),n.Check.defined("p1",o),n.Check.defined("p2",s),i.defined(u)||(u=new r.Cartesian3),i.defined(t.z)){if(r.Cartesian3.equalsEpsilon(e,t,a.CesiumMath.EPSILON14))return r.Cartesian3.clone(r.Cartesian3.UNIT_X,u);if(r.Cartesian3.equalsEpsilon(e,o,a.CesiumMath.EPSILON14))return r.Cartesian3.clone(r.Cartesian3.UNIT_Y,u);if(r.Cartesian3.equalsEpsilon(e,s,a.CesiumMath.EPSILON14))return r.Cartesian3.clone(r.Cartesian3.UNIT_Z,u);l=r.Cartesian3.subtract(o,t,d),p=r.Cartesian3.subtract(s,t,f),c=r.Cartesian3.subtract(e,t,m),y=r.Cartesian3.dot(l,l),h=r.Cartesian3.dot(l,p),v=r.Cartesian3.dot(l,c),C=r.Cartesian3.dot(p,p),b=r.Cartesian3.dot(p,c)}else{if(r.Cartesian2.equalsEpsilon(e,t,a.CesiumMath.EPSILON14))return r.Cartesian3.clone(r.Cartesian3.UNIT_X,u);if(r.Cartesian2.equalsEpsilon(e,o,a.CesiumMath.EPSILON14))return r.Cartesian3.clone(r.Cartesian3.UNIT_Y,u);if(r.Cartesian2.equalsEpsilon(e,s,a.CesiumMath.EPSILON14))return r.Cartesian3.clone(r.Cartesian3.UNIT_Z,u);l=r.Cartesian2.subtract(o,t,d),p=r.Cartesian2.subtract(s,t,f),c=r.Cartesian2.subtract(e,t,m),y=r.Cartesian2.dot(l,l),h=r.Cartesian2.dot(l,p),v=r.Cartesian2.dot(l,c),C=r.Cartesian2.dot(p,p),b=r.Cartesian2.dot(p,c)}u.y=C*v-h*b,u.z=y*b-h*v;const w=y*C-h*h;if(0!==w)return u.y/=w,u.z/=w,u.x=1-u.y-u.z,u}const h={calculateACMR:function(e){e=i.defaultValue(e,i.defaultValue.EMPTY_OBJECT);const t=e.indices;let r=e.maximumIndex;const a=i.defaultValue(e.cacheSize,24);if(!i.defined(t))throw new n.DeveloperError("indices is required.");const o=t.length;if(o<3||o%3!==0)throw new n.DeveloperError("indices length must be a multiple of three.");if(r<=0)throw new n.DeveloperError("maximumIndex must be greater than zero.");if(a<3)throw new n.DeveloperError("cacheSize must be greater than two.");if(!i.defined(r)){r=0;let e=0,n=t[e];while(e<o)n>r&&(r=n),++e,n=t[e]}const s=[];for(let n=0;n<r+1;n++)s[n]=0;let u=a+1;for(let n=0;n<o;++n)u-s[t[n]]>a&&(s[t[n]]=u,++u);return(u-a+1)/(o/3)},tipsify:function(e){e=i.defaultValue(e,i.defaultValue.EMPTY_OBJECT);const t=e.indices,r=e.maximumIndex,a=i.defaultValue(e.cacheSize,24);let o;function s(e,t,r,n){while(t.length>=1){const r=t[t.length-1];if(t.splice(t.length-1,1),e[r].numLiveTriangles>0)return r}while(o<n){if(e[o].numLiveTriangles>0)return++o,o-1;++o}return-1}function u(e,t,r,n,i,a,o){let u,l=-1,p=-1,c=0;while(c<r.length){const e=r[c];n[e].numLiveTriangles&&(u=0,i-n[e].timeStamp+2*n[e].numLiveTriangles<=t&&(u=i-n[e].timeStamp),(u>p||-1===p)&&(p=u,l=e)),++c}return-1===l?s(n,a,e,o):l}if(!i.defined(t))throw new n.DeveloperError("indices is required.");const l=t.length;if(l<3||l%3!==0)throw new n.DeveloperError("indices length must be a multiple of three.");if(r<=0)throw new n.DeveloperError("maximumIndex must be greater than zero.");if(a<3)throw new n.DeveloperError("cacheSize must be greater than two.");let p=0,c=0,d=t[c];const f=l;if(i.defined(r))p=r+1;else{while(c<f)d>p&&(p=d),++c,d=t[c];if(-1===p)return 0;++p}const m=[];let y;for(y=0;y<p;y++)m[y]={numLiveTriangles:0,timeStamp:0,vertexTriangles:[]};c=0;let h=0;while(c<f)m[t[c]].vertexTriangles.push(h),++m[t[c]].numLiveTriangles,m[t[c+1]].vertexTriangles.push(h),++m[t[c+1]].numLiveTriangles,m[t[c+2]].vertexTriangles.push(h),++m[t[c+2]].numLiveTriangles,++h,c+=3;let v=0,C=a+1;o=1;let b=[];const w=[];let g,T,A=0;const E=[],D=l/3,x=[];for(y=0;y<D;y++)x[y]=!1;let P,I;while(-1!==v){b=[],T=m[v],I=T.vertexTriangles.length;for(let e=0;e<I;++e)if(h=T.vertexTriangles[e],!x[h]){x[h]=!0,c=h+h+h;for(let e=0;e<3;++e)P=t[c],b.push(P),w.push(P),E[A]=P,++A,g=m[P],--g.numLiveTriangles,C-g.timeStamp>a&&(g.timeStamp=C,++C),++c}v=u(t,a,b,m,C,w,p)}return E}},v={};function C(e,t,r,n,i){e[t++]=r,e[t++]=n,e[t++]=n,e[t++]=i,e[t++]=i,e[t]=r}function b(e){const t=e.length,r=t/3*6,n=l.IndexDatatype.createTypedArray(t,r);let i=0;for(let a=0;a<t;a+=3,i+=6)C(n,i,e[a],e[a+1],e[a+2]);return n}function w(e){const t=e.length;if(t>=3){const r=6*(t-2),n=l.IndexDatatype.createTypedArray(t,r);C(n,0,e[0],e[1],e[2]);let i=6;for(let a=3;a<t;++a,i+=6)C(n,i,e[a-1],e[a],e[a-2]);return n}return new Uint16Array}function g(e){if(e.length>0){const t=e.length-1,r=6*(t-1),n=l.IndexDatatype.createTypedArray(t,r),i=e[0];let a=0;for(let o=1;o<t;++o,a+=6)C(n,a,i,e[o],e[o+1]);return n}return new Uint16Array}function T(e){const t={};for(const r in e)if(e.hasOwnProperty(r)&&i.defined(e[r])&&i.defined(e[r].values)){const n=e[r];t[r]=new u.GeometryAttribute({componentDatatype:n.componentDatatype,componentsPerAttribute:n.componentsPerAttribute,normalize:n.normalize,values:[]})}return t}function A(e,t,r){for(const n in t)if(t.hasOwnProperty(n)&&i.defined(t[n])&&i.defined(t[n].values)){const i=t[n];for(let t=0;t<i.componentsPerAttribute;++t)e[n].values.push(i.values[r*i.componentsPerAttribute+t])}}v.toWireframe=function(e){if(!i.defined(e))throw new n.DeveloperError("geometry is required.");const t=e.indices;if(i.defined(t)){switch(e.primitiveType){case u.PrimitiveType.TRIANGLES:e.indices=b(t);break;case u.PrimitiveType.TRIANGLE_STRIP:e.indices=w(t);break;case u.PrimitiveType.TRIANGLE_FAN:e.indices=g(t);break;default:throw new n.DeveloperError("geometry.primitiveType must be TRIANGLES, TRIANGLE_STRIP, or TRIANGLE_FAN.")}e.primitiveType=u.PrimitiveType.LINES}return e},v.createLineSegmentsForVectors=function(e,t,r){if(t=i.defaultValue(t,"normal"),!i.defined(e))throw new n.DeveloperError("geometry is required.");if(!i.defined(e.attributes.position))throw new n.DeveloperError("geometry.attributes.position is required.");if(!i.defined(e.attributes[t]))throw new n.DeveloperError(`geometry.attributes must have an attribute with the same name as the attributeName parameter, ${t}.`);r=i.defaultValue(r,1e4);const s=e.attributes.position.values,l=e.attributes[t].values,p=s.length,c=new Float64Array(2*p);let d,f=0;for(let n=0;n<p;n+=3)c[f++]=s[n],c[f++]=s[n+1],c[f++]=s[n+2],c[f++]=s[n]+l[n]*r,c[f++]=s[n+1]+l[n+1]*r,c[f++]=s[n+2]+l[n+2]*r;const m=e.boundingSphere;return i.defined(m)&&(d=new o.BoundingSphere(m.center,m.radius+r)),new u.Geometry({attributes:{position:new u.GeometryAttribute({componentDatatype:a.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:c})},primitiveType:u.PrimitiveType.LINES,boundingSphere:d})},v.createAttributeLocations=function(e){if(!i.defined(e))throw new n.DeveloperError("geometry is required.");const t=["position","positionHigh","positionLow","position3DHigh","position3DLow","position2DHigh","position2DLow","pickColor","normal","st","tangent","bitangent","extrudeDirection","compressedAttributes"],r=e.attributes,a={};let o,s=0;const u=t.length;for(o=0;o<u;++o){const e=t[o];i.defined(r[e])&&(a[e]=s++)}for(const n in r)r.hasOwnProperty(n)&&!i.defined(a[n])&&(a[n]=s++);return a},v.reorderForPreVertexCache=function(e){if(!i.defined(e))throw new n.DeveloperError("geometry is required.");const t=u.Geometry.computeNumberOfVertices(e),r=e.indices;if(i.defined(r)){const n=new Int32Array(t);for(let e=0;e<t;e++)n[e]=-1;const o=r,s=o.length,u=l.IndexDatatype.createTypedArray(t,s);let p,c=0,d=0,f=0;while(c<s)p=n[o[c]],-1!==p?u[d]=p:(p=o[c],n[p]=f,u[d]=f,++f),++c,++d;e.indices=u;const m=e.attributes;for(const e in m)if(m.hasOwnProperty(e)&&i.defined(m[e])&&i.defined(m[e].values)){const r=m[e],i=r.values;let o=0;const s=r.componentsPerAttribute,u=a.ComponentDatatype.createTypedArray(r.componentDatatype,f*s);while(o<t){const e=n[o];if(-1!==e)for(let t=0;t<s;t++)u[s*e+t]=i[s*o+t];++o}r.values=u}}return e},v.reorderForPostVertexCache=function(e,t){if(!i.defined(e))throw new n.DeveloperError("geometry is required.");const r=e.indices;if(e.primitiveType===u.PrimitiveType.TRIANGLES&&i.defined(r)){const n=r.length;let i=0;for(let e=0;e<n;e++)r[e]>i&&(i=r[e]);e.indices=h.tipsify({indices:r,maximumIndex:i,cacheSize:t})}return e},v.fitToUnsignedShortIndices=function(e){if(!i.defined(e))throw new n.DeveloperError("geometry is required.");if(i.defined(e.indices)&&e.primitiveType!==u.PrimitiveType.TRIANGLES&&e.primitiveType!==u.PrimitiveType.LINES&&e.primitiveType!==u.PrimitiveType.POINTS)throw new n.DeveloperError("geometry.primitiveType must equal to PrimitiveType.TRIANGLES, PrimitiveType.LINES, or PrimitiveType.POINTS.");const t=[],r=u.Geometry.computeNumberOfVertices(e);if(i.defined(e.indices)&&r>=a.CesiumMath.SIXTY_FOUR_KILOBYTES){let r=[],n=[],o=0,s=T(e.attributes);const l=e.indices,p=l.length;let c;e.primitiveType===u.PrimitiveType.TRIANGLES?c=3:e.primitiveType===u.PrimitiveType.LINES?c=2:e.primitiveType===u.PrimitiveType.POINTS&&(c=1);for(let d=0;d<p;d+=c){for(let t=0;t<c;++t){const a=l[d+t];let u=r[a];i.defined(u)||(u=o++,r[a]=u,A(s,e.attributes,a)),n.push(u)}o+c>=a.CesiumMath.SIXTY_FOUR_KILOBYTES&&(t.push(new u.Geometry({attributes:s,indices:n,primitiveType:e.primitiveType,boundingSphere:e.boundingSphere,boundingSphereCV:e.boundingSphereCV})),r=[],n=[],o=0,s=T(e.attributes))}0!==n.length&&t.push(new u.Geometry({attributes:s,indices:n,primitiveType:e.primitiveType,boundingSphere:e.boundingSphere,boundingSphereCV:e.boundingSphereCV}))}else t.push(e);return t};const E=new r.Cartesian3,D=new r.Cartographic;v.projectTo2D=function(e,t,s,l,p){if(!i.defined(e))throw new n.DeveloperError("geometry is required.");if(!i.defined(t))throw new n.DeveloperError("attributeName is required.");if(!i.defined(s))throw new n.DeveloperError("attributeName3D is required.");if(!i.defined(l))throw new n.DeveloperError("attributeName2D is required.");if(!i.defined(e.attributes[t]))throw new n.DeveloperError(`geometry must have attribute matching the attributeName argument: ${t}.`);if(e.attributes[t].componentDatatype!==a.ComponentDatatype.DOUBLE)throw new n.DeveloperError("The attribute componentDatatype must be ComponentDatatype.DOUBLE.");const c=e.attributes[t];p=i.defined(p)?p:new o.GeographicProjection;const d=p.ellipsoid,f=c.values,m=new Float64Array(f.length);let y=0;for(let a=0;a<f.length;a+=3){const e=r.Cartesian3.fromArray(f,a,E),t=d.cartesianToCartographic(e,D);if(!i.defined(t))throw new n.DeveloperError(`Could not project point (${e.x}, ${e.y}, ${e.z}) to 2D.`);const o=p.project(t,E);m[y++]=o.x,m[y++]=o.y,m[y++]=o.z}return e.attributes[s]=c,e.attributes[l]=new u.GeometryAttribute({componentDatatype:a.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:m}),delete e.attributes[t],e};const x={high:0,low:0};v.encodeAttribute=function(e,t,r,o){if(!i.defined(e))throw new n.DeveloperError("geometry is required.");if(!i.defined(t))throw new n.DeveloperError("attributeName is required.");if(!i.defined(r))throw new n.DeveloperError("attributeHighName is required.");if(!i.defined(o))throw new n.DeveloperError("attributeLowName is required.");if(!i.defined(e.attributes[t]))throw new n.DeveloperError(`geometry must have attribute matching the attributeName argument: ${t}.`);if(e.attributes[t].componentDatatype!==a.ComponentDatatype.DOUBLE)throw new n.DeveloperError("The attribute componentDatatype must be ComponentDatatype.DOUBLE.");const l=e.attributes[t],p=l.values,c=p.length,d=new Float32Array(c),f=new Float32Array(c);for(let n=0;n<c;++n)s.EncodedCartesian3.encode(p[n],x),d[n]=x.high,f[n]=x.low;const m=l.componentsPerAttribute;return e.attributes[r]=new u.GeometryAttribute({componentDatatype:a.ComponentDatatype.FLOAT,componentsPerAttribute:m,values:d}),e.attributes[o]=new u.GeometryAttribute({componentDatatype:a.ComponentDatatype.FLOAT,componentsPerAttribute:m,values:f}),delete e.attributes[t],e};let P=new r.Cartesian3;function I(e,t){if(i.defined(t)){const n=t.values,i=n.length;for(let t=0;t<i;t+=3)r.Cartesian3.unpack(n,t,P),r.Matrix4.multiplyByPoint(e,P,P),r.Cartesian3.pack(P,n,t)}}function S(e,t){if(i.defined(t)){const n=t.values,i=n.length;for(let t=0;t<i;t+=3)r.Cartesian3.unpack(n,t,P),r.Matrix3.multiplyByVector(e,P,P),P=r.Cartesian3.normalize(P,P),r.Cartesian3.pack(P,n,t)}}const N=new r.Matrix4,O=new r.Matrix3;function L(e,t){const r=e.length,n={},o=e[0][t].attributes;let s;for(s in o)if(o.hasOwnProperty(s)&&i.defined(o[s])&&i.defined(o[s].values)){const l=o[s];let p=l.values.length,c=!0;for(let n=1;n<r;++n){const r=e[n][t].attributes[s];if(!i.defined(r)||l.componentDatatype!==r.componentDatatype||l.componentsPerAttribute!==r.componentsPerAttribute||l.normalize!==r.normalize){c=!1;break}p+=r.values.length}c&&(n[s]=new u.GeometryAttribute({componentDatatype:l.componentDatatype,componentsPerAttribute:l.componentsPerAttribute,normalize:l.normalize,values:a.ComponentDatatype.createTypedArray(l.componentDatatype,p)}))}return n}v.transformToWorldCoordinates=function(e){if(!i.defined(e))throw new n.DeveloperError("instance is required.");const t=e.modelMatrix;if(r.Matrix4.equals(t,r.Matrix4.IDENTITY))return e;const a=e.geometry.attributes;I(t,a.position),I(t,a.prevPosition),I(t,a.nextPosition),(i.defined(a.normal)||i.defined(a.tangent)||i.defined(a.bitangent))&&(r.Matrix4.inverse(t,N),r.Matrix4.transpose(N,N),r.Matrix4.getMatrix3(N,O),S(O,a.normal),S(O,a.tangent),S(O,a.bitangent));const s=e.geometry.boundingSphere;return i.defined(s)&&(e.geometry.boundingSphere=o.BoundingSphere.transform(s,t,s)),e.modelMatrix=r.Matrix4.clone(r.Matrix4.IDENTITY),e};const z=new r.Cartesian3;function G(e,t){const a=e.length;let s,p,c,d;const f=e[0].modelMatrix,m=i.defined(e[0][t].indices),y=e[0][t].primitiveType;for(p=1;p<a;++p){if(!r.Matrix4.equals(e[p].modelMatrix,f))throw new n.DeveloperError("All instances must have the same modelMatrix.");if(i.defined(e[p][t].indices)!==m)throw new n.DeveloperError("All instance geometries must have an indices or not have one.");if(e[p][t].primitiveType!==y)throw new n.DeveloperError("All instance geometries must have the same primitiveType.")}const h=L(e,t);let v,C,b,w;for(s in h)if(h.hasOwnProperty(s))for(v=h[s].values,d=0,p=0;p<a;++p)for(C=e[p][t].attributes[s].values,b=C.length,c=0;c<b;++c)v[d++]=C[c];if(m){let r=0;for(p=0;p<a;++p)r+=e[p][t].indices.length;const n=u.Geometry.computeNumberOfVertices(new u.Geometry({attributes:h,primitiveType:u.PrimitiveType.POINTS})),i=l.IndexDatatype.createTypedArray(n,r);let o=0,s=0;for(p=0;p<a;++p){const r=e[p][t].indices,n=r.length;for(d=0;d<n;++d)i[o++]=s+r[d];s+=u.Geometry.computeNumberOfVertices(e[p][t])}w=i}let g,T=new r.Cartesian3,A=0;for(p=0;p<a;++p){if(g=e[p][t].boundingSphere,!i.defined(g)){T=void 0;break}r.Cartesian3.add(g.center,T,T)}if(i.defined(T))for(r.Cartesian3.divideByScalar(T,a,T),p=0;p<a;++p){g=e[p][t].boundingSphere;const n=r.Cartesian3.magnitude(r.Cartesian3.subtract(g.center,T,z))+g.radius;n>A&&(A=n)}return new u.Geometry({attributes:h,indices:w,primitiveType:y,boundingSphere:i.defined(T)?new o.BoundingSphere(T,A):void 0})}v.combineInstances=function(e){if(!i.defined(e)||e.length<1)throw new n.DeveloperError("instances is required and must have length greater than zero.");const t=[],r=[],a=e.length;for(let n=0;n<a;++n){const a=e[n];i.defined(a.geometry)?t.push(a):i.defined(a.westHemisphereGeometry)&&i.defined(a.eastHemisphereGeometry)&&r.push(a)}const o=[];return t.length>0&&o.push(G(t,"geometry")),r.length>0&&(o.push(G(r,"westHemisphereGeometry")),o.push(G(r,"eastHemisphereGeometry"))),o};const M=new r.Cartesian3,q=new r.Cartesian3,R=new r.Cartesian3,V=new r.Cartesian3;v.computeNormal=function(e){if(!i.defined(e))throw new n.DeveloperError("geometry is required.");if(!i.defined(e.attributes.position)||!i.defined(e.attributes.position.values))throw new n.DeveloperError("geometry.attributes.position.values is required.");if(!i.defined(e.indices))throw new n.DeveloperError("geometry.indices is required.");if(e.indices.length<2||e.indices.length%3!==0)throw new n.DeveloperError("geometry.indices length must be greater than 0 and be a multiple of 3.");if(e.primitiveType!==u.PrimitiveType.TRIANGLES)throw new n.DeveloperError("geometry.primitiveType must be PrimitiveType.TRIANGLES.");const t=e.indices,o=e.attributes,s=o.position.values,l=o.position.values.length/3,p=t.length,c=new Array(l),d=new Array(p/3),f=new Array(p);let m;for(m=0;m<l;m++)c[m]={indexOffset:0,count:0,currentCount:0};let y=0;for(m=0;m<p;m+=3){const e=t[m],n=t[m+1],i=t[m+2],a=3*e,o=3*n,u=3*i;q.x=s[a],q.y=s[a+1],q.z=s[a+2],R.x=s[o],R.y=s[o+1],R.z=s[o+2],V.x=s[u],V.y=s[u+1],V.z=s[u+2],c[e].count++,c[n].count++,c[i].count++,r.Cartesian3.subtract(R,q,R),r.Cartesian3.subtract(V,q,V),d[y]=r.Cartesian3.cross(R,V,new r.Cartesian3),y++}let h,v=0;for(m=0;m<l;m++)c[m].indexOffset+=v,v+=c[m].count;for(y=0,m=0;m<p;m+=3){h=c[t[m]];let e=h.indexOffset+h.currentCount;f[e]=y,h.currentCount++,h=c[t[m+1]],e=h.indexOffset+h.currentCount,f[e]=y,h.currentCount++,h=c[t[m+2]],e=h.indexOffset+h.currentCount,f[e]=y,h.currentCount++,y++}const C=new Float32Array(3*l);for(m=0;m<l;m++){const e=3*m;if(h=c[m],r.Cartesian3.clone(r.Cartesian3.ZERO,M),h.count>0){for(y=0;y<h.count;y++)r.Cartesian3.add(M,d[f[h.indexOffset+y]],M);r.Cartesian3.equalsEpsilon(r.Cartesian3.ZERO,M,a.CesiumMath.EPSILON10)&&r.Cartesian3.clone(d[f[h.indexOffset]],M)}r.Cartesian3.equalsEpsilon(r.Cartesian3.ZERO,M,a.CesiumMath.EPSILON10)&&(M.z=1),r.Cartesian3.normalize(M,M),C[e]=M.x,C[e+1]=M.y,C[e+2]=M.z}return e.attributes.normal=new u.GeometryAttribute({componentDatatype:a.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:C}),e};const B=new r.Cartesian3,k=new r.Cartesian3,F=new r.Cartesian3;v.computeTangentAndBitangent=function(e){if(!i.defined(e))throw new n.DeveloperError("geometry is required.");const t=e.attributes,o=e.indices;if(!i.defined(t.position)||!i.defined(t.position.values))throw new n.DeveloperError("geometry.attributes.position.values is required.");if(!i.defined(t.normal)||!i.defined(t.normal.values))throw new n.DeveloperError("geometry.attributes.normal.values is required.");if(!i.defined(t.st)||!i.defined(t.st.values))throw new n.DeveloperError("geometry.attributes.st.values is required.");if(!i.defined(o))throw new n.DeveloperError("geometry.indices is required.");if(o.length<2||o.length%3!==0)throw new n.DeveloperError("geometry.indices length must be greater than 0 and be a multiple of 3.");if(e.primitiveType!==u.PrimitiveType.TRIANGLES)throw new n.DeveloperError("geometry.primitiveType must be PrimitiveType.TRIANGLES.");const s=e.attributes.position.values,l=e.attributes.normal.values,p=e.attributes.st.values,c=e.attributes.position.values.length/3,d=o.length,f=new Array(3*c);let m,y,h,v;for(m=0;m<f.length;m++)f[m]=0;for(m=0;m<d;m+=3){const e=o[m],t=o[m+1],r=o[m+2];y=3*e,h=3*t,v=3*r;const n=2*e,i=2*t,a=2*r,u=s[y],l=s[y+1],c=s[y+2],d=p[n],C=p[n+1],b=p[i+1]-C,w=p[a+1]-C,g=1/((p[i]-d)*w-(p[a]-d)*b),T=(w*(s[h]-u)-b*(s[v]-u))*g,A=(w*(s[h+1]-l)-b*(s[v+1]-l))*g,E=(w*(s[h+2]-c)-b*(s[v+2]-c))*g;f[y]+=T,f[y+1]+=A,f[y+2]+=E,f[h]+=T,f[h+1]+=A,f[h+2]+=E,f[v]+=T,f[v+1]+=A,f[v+2]+=E}const C=new Float32Array(3*c),b=new Float32Array(3*c);for(m=0;m<c;m++){y=3*m,h=y+1,v=y+2;const e=r.Cartesian3.fromArray(l,y,B),t=r.Cartesian3.fromArray(f,y,F),n=r.Cartesian3.dot(e,t);r.Cartesian3.multiplyByScalar(e,n,k),r.Cartesian3.normalize(r.Cartesian3.subtract(t,k,t),t),C[y]=t.x,C[h]=t.y,C[v]=t.z,r.Cartesian3.normalize(r.Cartesian3.cross(e,t,t),t),b[y]=t.x,b[h]=t.y,b[v]=t.z}return e.attributes.tangent=new u.GeometryAttribute({componentDatatype:a.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:C}),e.attributes.bitangent=new u.GeometryAttribute({componentDatatype:a.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:b}),e};const _=new r.Cartesian2,U=new r.Cartesian3,Y=new r.Cartesian3,Z=new r.Cartesian3;let H=new r.Cartesian2;function W(e){if(i.defined(e.indices))return e;const t=u.Geometry.computeNumberOfVertices(e);if(t<3)throw new n.DeveloperError("The number of vertices must be at least three.");if(t%3!==0)throw new n.DeveloperError("The number of vertices must be a multiple of three.");const r=l.IndexDatatype.createTypedArray(t,t);for(let n=0;n<t;++n)r[n]=n;return e.indices=r,e}function $(e){const t=u.Geometry.computeNumberOfVertices(e);if(t<3)throw new n.DeveloperError("The number of vertices must be at least three.");const r=l.IndexDatatype.createTypedArray(t,3*(t-2));r[0]=1,r[1]=0,r[2]=2;let i=3;for(let n=3;n<t;++n)r[i++]=n-1,r[i++]=0,r[i++]=n;return e.indices=r,e.primitiveType=u.PrimitiveType.TRIANGLES,e}function X(e){const t=u.Geometry.computeNumberOfVertices(e);if(t<3)throw new n.DeveloperError("The number of vertices must be at least 3.");const r=l.IndexDatatype.createTypedArray(t,3*(t-2));r[0]=0,r[1]=1,r[2]=2,t>3&&(r[3]=0,r[4]=2,r[5]=3);let i=6;for(let n=3;n<t-1;n+=2)r[i++]=n,r[i++]=n-1,r[i++]=n+1,n+2<t&&(r[i++]=n,r[i++]=n+1,r[i++]=n+2);return e.indices=r,e.primitiveType=u.PrimitiveType.TRIANGLES,e}function j(e){if(i.defined(e.indices))return e;const t=u.Geometry.computeNumberOfVertices(e);if(t<2)throw new n.DeveloperError("The number of vertices must be at least two.");if(t%2!==0)throw new n.DeveloperError("The number of vertices must be a multiple of 2.");const r=l.IndexDatatype.createTypedArray(t,t);for(let n=0;n<t;++n)r[n]=n;return e.indices=r,e}function J(e){const t=u.Geometry.computeNumberOfVertices(e);if(t<2)throw new n.DeveloperError("The number of vertices must be at least two.");const r=l.IndexDatatype.createTypedArray(t,2*(t-1));r[0]=0,r[1]=1;let i=2;for(let n=2;n<t;++n)r[i++]=n-1,r[i++]=n;return e.indices=r,e.primitiveType=u.PrimitiveType.LINES,e}function K(e){const t=u.Geometry.computeNumberOfVertices(e);if(t<2)throw new n.DeveloperError("The number of vertices must be at least two.");const r=l.IndexDatatype.createTypedArray(t,2*t);r[0]=0,r[1]=1;let i=2;for(let n=2;n<t;++n)r[i++]=n-1,r[i++]=n;return r[i++]=t-1,r[i]=0,e.indices=r,e.primitiveType=u.PrimitiveType.LINES,e}function Q(e){switch(e.primitiveType){case u.PrimitiveType.TRIANGLE_FAN:return $(e);case u.PrimitiveType.TRIANGLE_STRIP:return X(e);case u.PrimitiveType.TRIANGLES:return W(e);case u.PrimitiveType.LINE_STRIP:return J(e);case u.PrimitiveType.LINE_LOOP:return K(e);case u.PrimitiveType.LINES:return j(e)}return e}function ee(e,t){Math.abs(e.y)<a.CesiumMath.EPSILON6&&(e.y=t?-a.CesiumMath.EPSILON6:a.CesiumMath.EPSILON6)}function te(e,t,r){if(0!==e.y&&0!==t.y&&0!==r.y)return ee(e,e.y<0),ee(t,t.y<0),void ee(r,r.y<0);const n=Math.abs(e.y),i=Math.abs(t.y),o=Math.abs(r.y);let s;s=n>i?n>o?a.CesiumMath.sign(e.y):a.CesiumMath.sign(r.y):i>o?a.CesiumMath.sign(t.y):a.CesiumMath.sign(r.y);const u=s<0;ee(e,u),ee(t,u),ee(r,u)}v.compressVertices=function(e){if(!i.defined(e))throw new n.DeveloperError("geometry is required.");const o=e.attributes.extrudeDirection;let s,l;if(i.defined(o)){const n=o.values;l=n.length/3;const i=new Float32Array(2*l);let p=0;for(s=0;s<l;++s)r.Cartesian3.fromArray(n,3*s,U),r.Cartesian3.equals(U,r.Cartesian3.ZERO)?p+=2:(H=t.AttributeCompression.octEncodeInRange(U,65535,H),i[p++]=H.x,i[p++]=H.y);return e.attributes.compressedAttributes=new u.GeometryAttribute({componentDatatype:a.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:i}),delete e.attributes.extrudeDirection,e}const p=e.attributes.normal,c=e.attributes.st,d=i.defined(p),f=i.defined(c);if(!d&&!f)return e;const m=e.attributes.tangent,y=e.attributes.bitangent,h=i.defined(m),v=i.defined(y);let C,b,w,g;d&&(C=p.values),f&&(b=c.values),h&&(w=m.values),v&&(g=y.values);const T=d?C.length:b.length,A=d?3:2;l=T/A;let E=l,D=f&&d?2:1;D+=h||v?1:0,E*=D;const x=new Float32Array(E);let P=0;for(s=0;s<l;++s){f&&(r.Cartesian2.fromArray(b,2*s,_),x[P++]=t.AttributeCompression.compressTextureCoordinates(_));const e=3*s;d&&i.defined(w)&&i.defined(g)?(r.Cartesian3.fromArray(C,e,U),r.Cartesian3.fromArray(w,e,Y),r.Cartesian3.fromArray(g,e,Z),t.AttributeCompression.octPack(U,Y,Z,_),x[P++]=_.x,x[P++]=_.y):(d&&(r.Cartesian3.fromArray(C,e,U),x[P++]=t.AttributeCompression.octEncodeFloat(U)),h&&(r.Cartesian3.fromArray(w,e,U),x[P++]=t.AttributeCompression.octEncodeFloat(U)),v&&(r.Cartesian3.fromArray(g,e,U),x[P++]=t.AttributeCompression.octEncodeFloat(U)))}return e.attributes.compressedAttributes=new u.GeometryAttribute({componentDatatype:a.ComponentDatatype.FLOAT,componentsPerAttribute:D,values:x}),d&&delete e.attributes.normal,f&&delete e.attributes.st,v&&delete e.attributes.bitangent,h&&delete e.attributes.tangent,e};const re=new r.Cartesian3;function ne(e,t,n,i){r.Cartesian3.add(e,r.Cartesian3.multiplyByScalar(r.Cartesian3.subtract(t,e,re),e.y/(e.y-t.y),re),n),r.Cartesian3.clone(n,i),ee(n,!0),ee(i,!1)}const ie=new r.Cartesian3,ae=new r.Cartesian3,oe=new r.Cartesian3,se=new r.Cartesian3,ue={positions:new Array(7),indices:new Array(9)};function le(e,t,r){if(e.x>=0||t.x>=0||r.x>=0)return;te(e,t,r);const n=e.y<0,i=t.y<0,a=r.y<0;let o=0;o+=n?1:0,o+=i?1:0,o+=a?1:0;const s=ue.indices;1===o?(s[1]=3,s[2]=4,s[5]=6,s[7]=6,s[8]=5,n?(ne(e,t,ie,oe),ne(e,r,ae,se),s[0]=0,s[3]=1,s[4]=2,s[6]=1):i?(ne(t,r,ie,oe),ne(t,e,ae,se),s[0]=1,s[3]=2,s[4]=0,s[6]=2):a&&(ne(r,e,ie,oe),ne(r,t,ae,se),s[0]=2,s[3]=0,s[4]=1,s[6]=0)):2===o&&(s[2]=4,s[4]=4,s[5]=3,s[7]=5,s[8]=6,n?i?a||(ne(r,e,ie,oe),ne(r,t,ae,se),s[0]=0,s[1]=1,s[3]=0,s[6]=2):(ne(t,r,ie,oe),ne(t,e,ae,se),s[0]=2,s[1]=0,s[3]=2,s[6]=1):(ne(e,t,ie,oe),ne(e,r,ae,se),s[0]=1,s[1]=2,s[3]=1,s[6]=0));const u=ue.positions;return u[0]=e,u[1]=t,u[2]=r,u.length=3,1!==o&&2!==o||(u[3]=ie,u[4]=ae,u[5]=oe,u[6]=se,u.length=7),ue}function pe(e,t){const r=e.attributes;if(0===r.position.values.length)return;for(const o in r)if(r.hasOwnProperty(o)&&i.defined(r[o])&&i.defined(r[o].values)){const e=r[o];e.values=a.ComponentDatatype.createTypedArray(e.componentDatatype,e.values)}const n=u.Geometry.computeNumberOfVertices(e);return e.indices=l.IndexDatatype.createTypedArray(n,e.indices),t&&(e.boundingSphere=o.BoundingSphere.fromVertices(r.position.values)),e}function ce(e){const t=e.attributes,r={};for(const n in t)if(t.hasOwnProperty(n)&&i.defined(t[n])&&i.defined(t[n].values)){const e=t[n];r[n]=new u.GeometryAttribute({componentDatatype:e.componentDatatype,componentsPerAttribute:e.componentsPerAttribute,normalize:e.normalize,values:[]})}return new u.Geometry({attributes:r,indices:[],primitiveType:e.primitiveType})}function de(e,t,r){const n=i.defined(e.geometry.boundingSphere);t=pe(t,n),r=pe(r,n),i.defined(r)&&!i.defined(t)?e.geometry=r:!i.defined(r)&&i.defined(t)?e.geometry=t:(e.westHemisphereGeometry=t,e.eastHemisphereGeometry=r,e.geometry=void 0)}function fe(e,t){const r=new e,n=new e,i=new e;return function(a,o,s,u,l,p,c,d){const f=e.fromArray(l,a*t,r),m=e.fromArray(l,o*t,n),y=e.fromArray(l,s*t,i);e.multiplyByScalar(f,u.x,f),e.multiplyByScalar(m,u.y,m),e.multiplyByScalar(y,u.z,y);const h=e.add(f,m,f);e.add(h,y,h),d&&e.normalize(h,h),e.pack(h,p,c*t)}}const me=fe(r.Cartesian4,4),ye=fe(r.Cartesian3,3),he=fe(r.Cartesian2,2),ve=function(e,t,r,n,i,o,s){const u=i[e]*n.x,l=i[t]*n.y,p=i[r]*n.z;o[s]=u+l+p>a.CesiumMath.EPSILON6?1:0},Ce=new r.Cartesian3,be=new r.Cartesian3,we=new r.Cartesian3,ge=new r.Cartesian3;function Te(e,t,n,a,o,s,u,l,p,c,d,f,m,h,v,C){if(!i.defined(s)&&!i.defined(u)&&!i.defined(l)&&!i.defined(p)&&!i.defined(c)&&0===h)return;const b=r.Cartesian3.fromArray(o,3*e,Ce),w=r.Cartesian3.fromArray(o,3*t,be),g=r.Cartesian3.fromArray(o,3*n,we),T=y(a,b,w,g,ge);if(i.defined(T)){if(i.defined(s)&&ye(e,t,n,T,s,f.normal.values,C,!0),i.defined(c)){const i=r.Cartesian3.fromArray(c,3*e,Ce),a=r.Cartesian3.fromArray(c,3*t,be),o=r.Cartesian3.fromArray(c,3*n,we);let s;r.Cartesian3.multiplyByScalar(i,T.x,i),r.Cartesian3.multiplyByScalar(a,T.y,a),r.Cartesian3.multiplyByScalar(o,T.z,o),r.Cartesian3.equals(i,r.Cartesian3.ZERO)&&r.Cartesian3.equals(a,r.Cartesian3.ZERO)&&r.Cartesian3.equals(o,r.Cartesian3.ZERO)?(s=Ce,s.x=0,s.y=0,s.z=0):(s=r.Cartesian3.add(i,a,i),r.Cartesian3.add(s,o,s),r.Cartesian3.normalize(s,s)),r.Cartesian3.pack(s,f.extrudeDirection.values,3*C)}if(i.defined(d)&&ve(e,t,n,T,d,f.applyOffset.values,C),i.defined(u)&&ye(e,t,n,T,u,f.tangent.values,C,!0),i.defined(l)&&ye(e,t,n,T,l,f.bitangent.values,C,!0),i.defined(p)&&he(e,t,n,T,p,f.st.values,C),h>0)for(let r=0;r<h;r++){const i=m[r];Ae(e,t,n,T,C,v[i],f[i])}}}function Ae(e,t,r,n,i,a,o){const s=a.componentsPerAttribute,u=a.values,l=o.values;switch(s){case 4:me(e,t,r,n,u,l,i,!1);break;case 3:ye(e,t,r,n,u,l,i,!1);break;case 2:he(e,t,r,n,u,l,i,!1);break;default:l[i]=u[e]*n.x+u[t]*n.y+u[r]*n.z}}function Ee(e,t,r,n,i,a){const o=e.position.values.length/3;if(-1!==i){const s=n[i],u=r[s];return-1===u?(r[s]=o,e.position.values.push(a.x,a.y,a.z),t.push(o),o):(t.push(u),u)}return e.position.values.push(a.x,a.y,a.z),t.push(o),o}const De={position:!0,normal:!0,bitangent:!0,tangent:!0,st:!0,extrudeDirection:!0,applyOffset:!0};function xe(e){const t=e.geometry,n=t.attributes,a=n.position.values,o=i.defined(n.normal)?n.normal.values:void 0,s=i.defined(n.bitangent)?n.bitangent.values:void 0,u=i.defined(n.tangent)?n.tangent.values:void 0,l=i.defined(n.st)?n.st.values:void 0,p=i.defined(n.extrudeDirection)?n.extrudeDirection.values:void 0,c=i.defined(n.applyOffset)?n.applyOffset.values:void 0,d=t.indices,f=[];for(const r in n)n.hasOwnProperty(r)&&!De[r]&&i.defined(n[r])&&f.push(r);const m=f.length,y=ce(t),h=ce(t);let v,C,b,w,g;const T=[];T.length=a.length/3;const A=[];for(A.length=a.length/3,g=0;g<T.length;++g)T[g]=-1,A[g]=-1;const E=d.length;for(g=0;g<E;g+=3){const e=d[g],t=d[g+1],E=d[g+2];let D=r.Cartesian3.fromArray(a,3*e),x=r.Cartesian3.fromArray(a,3*t),P=r.Cartesian3.fromArray(a,3*E);const I=le(D,x,P);if(i.defined(I)&&I.positions.length>3){const r=I.positions,i=I.indices,D=i.length;for(let x=0;x<D;++x){const D=i[x],P=r[D];P.y<0?(v=h.attributes,C=h.indices,b=T):(v=y.attributes,C=y.indices,b=A),w=Ee(v,C,b,d,D<3?g+D:-1,P),Te(e,t,E,P,a,o,u,s,l,p,c,v,f,m,n,w)}}else i.defined(I)&&(D=I.positions[0],x=I.positions[1],P=I.positions[2]),D.y<0?(v=h.attributes,C=h.indices,b=T):(v=y.attributes,C=y.indices,b=A),w=Ee(v,C,b,d,g,D),Te(e,t,E,D,a,o,u,s,l,p,c,v,f,m,n,w),w=Ee(v,C,b,d,g+1,x),Te(e,t,E,x,a,o,u,s,l,p,c,v,f,m,n,w),w=Ee(v,C,b,d,g+2,P),Te(e,t,E,P,a,o,u,s,l,p,c,v,f,m,n,w)}de(e,h,y)}const Pe=c.Plane.fromPointNormal(r.Cartesian3.ZERO,r.Cartesian3.UNIT_Y),Ie=new r.Cartesian3,Se=new r.Cartesian3;function Ne(e,t,n,o,s,u,l){if(!i.defined(l))return;const p=r.Cartesian3.fromArray(o,3*e,Ce);r.Cartesian3.equalsEpsilon(p,n,a.CesiumMath.EPSILON10)?u.applyOffset.values[s]=l[e]:u.applyOffset.values[s]=l[t]}function Oe(e){const t=e.geometry,n=t.attributes,o=n.position.values,s=i.defined(n.applyOffset)?n.applyOffset.values:void 0,u=t.indices,l=ce(t),c=ce(t);let d;const f=u.length,m=[];m.length=o.length/3;const y=[];for(y.length=o.length/3,d=0;d<m.length;++d)m[d]=-1,y[d]=-1;for(d=0;d<f;d+=2){const e=u[d],t=u[d+1],n=r.Cartesian3.fromArray(o,3*e,Ce),f=r.Cartesian3.fromArray(o,3*t,be);let h;Math.abs(n.y)<a.CesiumMath.EPSILON6&&(n.y<0?n.y=-a.CesiumMath.EPSILON6:n.y=a.CesiumMath.EPSILON6),Math.abs(f.y)<a.CesiumMath.EPSILON6&&(f.y<0?f.y=-a.CesiumMath.EPSILON6:f.y=a.CesiumMath.EPSILON6);let v=l.attributes,C=l.indices,b=y,w=c.attributes,g=c.indices,T=m;const A=p.IntersectionTests.lineSegmentPlane(n,f,Pe,we);if(i.defined(A)){const i=r.Cartesian3.multiplyByScalar(r.Cartesian3.UNIT_Y,5*a.CesiumMath.EPSILON9,Ie);n.y<0&&(r.Cartesian3.negate(i,i),v=c.attributes,C=c.indices,b=m,w=l.attributes,g=l.indices,T=y);const p=r.Cartesian3.add(A,i,Se);h=Ee(v,C,b,u,d,n),Ne(e,t,n,o,h,v,s),h=Ee(v,C,b,u,-1,p),Ne(e,t,p,o,h,v,s),r.Cartesian3.negate(i,i),r.Cartesian3.add(A,i,p),h=Ee(w,g,T,u,-1,p),Ne(e,t,p,o,h,w,s),h=Ee(w,g,T,u,d+1,f),Ne(e,t,f,o,h,w,s)}else{let r,i,a;n.y<0?(r=c.attributes,i=c.indices,a=m):(r=l.attributes,i=l.indices,a=y),h=Ee(r,i,a,u,d,n),Ne(e,t,n,o,h,r,s),h=Ee(r,i,a,u,d+1,f),Ne(e,t,f,o,h,r,s)}}de(e,c,l)}const Le=new r.Cartesian2,ze=new r.Cartesian2,Ge=new r.Cartesian3,Me=new r.Cartesian3,qe=new r.Cartesian3,Re=new r.Cartesian3,Ve=new r.Cartesian3,Be=new r.Cartesian3,ke=new r.Cartesian4;function Fe(e){const t=e.attributes,n=t.position.values,i=t.prevPosition.values,a=t.nextPosition.values,o=n.length;for(let s=0;s<o;s+=3){const e=r.Cartesian3.unpack(n,s,Ge);if(e.x>0)continue;const t=r.Cartesian3.unpack(i,s,Me);(e.y<0&&t.y>0||e.y>0&&t.y<0)&&(s-3>0?(i[s]=n[s-3],i[s+1]=n[s-2],i[s+2]=n[s-1]):r.Cartesian3.pack(e,i,s));const u=r.Cartesian3.unpack(a,s,qe);(e.y<0&&u.y>0||e.y>0&&u.y<0)&&(s+3<o?(a[s]=n[s+3],a[s+1]=n[s+4],a[s+2]=n[s+5]):r.Cartesian3.pack(e,a,s))}}const _e=5*a.CesiumMath.EPSILON9,Ue=a.CesiumMath.EPSILON6;function Ye(e){const t=e.geometry,n=t.attributes,o=n.position.values,s=n.prevPosition.values,u=n.nextPosition.values,l=n.expandAndWidth.values,c=i.defined(n.st)?n.st.values:void 0,d=i.defined(n.color)?n.color.values:void 0,f=ce(t),m=ce(t);let y,h,v,C=!1;const b=o.length/3;for(y=0;y<b;y+=4){const e=y,t=y+2,n=r.Cartesian3.fromArray(o,3*e,Ge),b=r.Cartesian3.fromArray(o,3*t,Me);if(Math.abs(n.y)<Ue)for(n.y=Ue*(b.y<0?-1:1),o[3*y+1]=n.y,o[3*(y+1)+1]=n.y,h=3*e;h<3*e+12;h+=3)s[h]=o[3*y],s[h+1]=o[3*y+1],s[h+2]=o[3*y+2];if(Math.abs(b.y)<Ue)for(b.y=Ue*(n.y<0?-1:1),o[3*(y+2)+1]=b.y,o[3*(y+3)+1]=b.y,h=3*e;h<3*e+12;h+=3)u[h]=o[3*(y+2)],u[h+1]=o[3*(y+2)+1],u[h+2]=o[3*(y+2)+2];let w=f.attributes,g=f.indices,T=m.attributes,A=m.indices;const E=p.IntersectionTests.lineSegmentPlane(n,b,Pe,Re);if(i.defined(E)){C=!0;const o=r.Cartesian3.multiplyByScalar(r.Cartesian3.UNIT_Y,_e,Ve);n.y<0&&(r.Cartesian3.negate(o,o),w=m.attributes,g=m.indices,T=f.attributes,A=f.indices);const p=r.Cartesian3.add(E,o,Be);w.position.values.push(n.x,n.y,n.z,n.x,n.y,n.z),w.position.values.push(p.x,p.y,p.z),w.position.values.push(p.x,p.y,p.z),w.prevPosition.values.push(s[3*e],s[3*e+1],s[3*e+2]),w.prevPosition.values.push(s[3*e+3],s[3*e+4],s[3*e+5]),w.prevPosition.values.push(n.x,n.y,n.z,n.x,n.y,n.z),w.nextPosition.values.push(p.x,p.y,p.z),w.nextPosition.values.push(p.x,p.y,p.z),w.nextPosition.values.push(p.x,p.y,p.z),w.nextPosition.values.push(p.x,p.y,p.z),r.Cartesian3.negate(o,o),r.Cartesian3.add(E,o,p),T.position.values.push(p.x,p.y,p.z),T.position.values.push(p.x,p.y,p.z),T.position.values.push(b.x,b.y,b.z,b.x,b.y,b.z),T.prevPosition.values.push(p.x,p.y,p.z),T.prevPosition.values.push(p.x,p.y,p.z),T.prevPosition.values.push(p.x,p.y,p.z),T.prevPosition.values.push(p.x,p.y,p.z),T.nextPosition.values.push(b.x,b.y,b.z,b.x,b.y,b.z),T.nextPosition.values.push(u[3*t],u[3*t+1],u[3*t+2]),T.nextPosition.values.push(u[3*t+3],u[3*t+4],u[3*t+5]);const D=r.Cartesian2.fromArray(l,2*e,Le),x=Math.abs(D.y);w.expandAndWidth.values.push(-1,x,1,x),w.expandAndWidth.values.push(-1,-x,1,-x),T.expandAndWidth.values.push(-1,x,1,x),T.expandAndWidth.values.push(-1,-x,1,-x);let P=r.Cartesian3.magnitudeSquared(r.Cartesian3.subtract(E,n,qe));if(P/=r.Cartesian3.magnitudeSquared(r.Cartesian3.subtract(b,n,qe)),i.defined(d)){const n=r.Cartesian4.fromArray(d,4*e,ke),i=r.Cartesian4.fromArray(d,4*t,ke),o=a.CesiumMath.lerp(n.x,i.x,P),s=a.CesiumMath.lerp(n.y,i.y,P),u=a.CesiumMath.lerp(n.z,i.z,P),l=a.CesiumMath.lerp(n.w,i.w,P);for(h=4*e;h<4*e+8;++h)w.color.values.push(d[h]);for(w.color.values.push(o,s,u,l),w.color.values.push(o,s,u,l),T.color.values.push(o,s,u,l),T.color.values.push(o,s,u,l),h=4*t;h<4*t+8;++h)T.color.values.push(d[h])}if(i.defined(c)){const n=r.Cartesian2.fromArray(c,2*e,Le),i=r.Cartesian2.fromArray(c,2*(y+3),ze),o=a.CesiumMath.lerp(n.x,i.x,P);for(h=2*e;h<2*e+4;++h)w.st.values.push(c[h]);for(w.st.values.push(o,n.y),w.st.values.push(o,i.y),T.st.values.push(o,n.y),T.st.values.push(o,i.y),h=2*t;h<2*t+4;++h)T.st.values.push(c[h])}v=w.position.values.length/3-4,g.push(v,v+2,v+1),g.push(v+1,v+2,v+3),v=T.position.values.length/3-4,A.push(v,v+2,v+1),A.push(v+1,v+2,v+3)}else{let e,t;for(n.y<0?(e=m.attributes,t=m.indices):(e=f.attributes,t=f.indices),e.position.values.push(n.x,n.y,n.z),e.position.values.push(n.x,n.y,n.z),e.position.values.push(b.x,b.y,b.z),e.position.values.push(b.x,b.y,b.z),h=3*y;h<3*y+12;++h)e.prevPosition.values.push(s[h]),e.nextPosition.values.push(u[h]);for(h=2*y;h<2*y+8;++h)e.expandAndWidth.values.push(l[h]),i.defined(c)&&e.st.values.push(c[h]);if(i.defined(d))for(h=4*y;h<4*y+16;++h)e.color.values.push(d[h]);v=e.position.values.length/3-4,t.push(v,v+2,v+1),t.push(v+1,v+2,v+3)}}C&&(Fe(m),Fe(f)),de(e,m,f)}v.splitLongitude=function(e){if(!i.defined(e))throw new n.DeveloperError("instance is required.");const t=e.geometry,r=t.boundingSphere;if(i.defined(r)){const t=r.center.x-r.radius;if(t>0||o.BoundingSphere.intersectPlane(r,c.Plane.ORIGIN_ZX_PLANE)!==o.Intersect.INTERSECTING)return e}if(t.geometryType!==u.GeometryType.NONE)switch(t.geometryType){case u.GeometryType.POLYLINES:Ye(e);break;case u.GeometryType.TRIANGLES:xe(e);break;case u.GeometryType.LINES:Oe(e);break}else Q(t),t.primitiveType===u.PrimitiveType.TRIANGLES?xe(e):t.primitiveType===u.PrimitiveType.LINES&&Oe(e);return e},e.GeometryPipeline=v}));