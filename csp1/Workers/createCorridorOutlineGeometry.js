define(["./GeometryOffsetAttribute-3e8c299c","./arrayRemoveDuplicates-06991c15","./Transforms-a076dbe6","./Matrix2-fc7e9822","./RuntimeError-c581ca93","./ComponentDatatype-4a60b8d6","./PolylineVolumeGeometryLibrary-759a8d46","./CorridorGeometryLibrary-3d47380e","./defaultValue-94c3e563","./GeometryAttribute-2ecf73f6","./GeometryAttributes-7df9bef6","./IndexDatatype-db156785","./PolygonPipeline-cc031b9f","./_commonjsHelpers-3aae1032-f55dc0c4","./combine-761d9c3f","./WebGLConstants-7dccdc96","./EllipsoidTangentPlane-d2c0c530","./AxisAlignedBoundingBox-8103739f","./IntersectionTests-5deed78b","./Plane-e20fba8c","./PolylinePipeline-7608e667","./EllipsoidGeodesic-dc94f381","./EllipsoidRhumbLine-daebc75b"],(function(e,t,i,r,o,n,s,a,l,d,u,c,p,f,h,y,g,b,m,A,_,C,E){"use strict";const G=new r.Cartesian3,T=new r.Cartesian3,P=new r.Cartesian3;function v(e,t){for(let i=0;i<e.length;i++)e[i]=t.scaleToGeodeticSurface(e[i],e[i]);return e}function w(e,t){const i=[],o=e.positions,p=e.corners,f=e.endPositions,h=new u.GeometryAttributes;let y,g,b,m=0,A=0,_=0;for(g=0;g<o.length;g+=2)b=o[g].length-3,m+=b,_+=b/3*4,A+=o[g+1].length-3;for(m+=3,A+=3,g=0;g<p.length;g++){y=p[g];const e=p[g].leftPositions;l.defined(e)?(b=e.length,m+=b,_+=b/3*2):(b=p[g].rightPositions.length,A+=b,_+=b/3*2)}const C=l.defined(f);let E;C&&(E=f[0].length-3,m+=E,A+=E,E/=3,_+=4*E);const v=m+A,w=new Float64Array(v);let L,D,k,O,x,V,H=0,N=v-1;const I=E/2,S=c.IndexDatatype.createTypedArray(v/3,_+4);let B=0;if(S[B++]=H/3,S[B++]=(N-2)/3,C){i.push(H/3),V=G,x=T;const e=f[0];for(g=0;g<I;g++)V=r.Cartesian3.fromArray(e,3*(I-1-g),V),x=r.Cartesian3.fromArray(e,3*(I+g),x),a.CorridorGeometryLibrary.addAttribute(w,x,H),a.CorridorGeometryLibrary.addAttribute(w,V,void 0,N),D=H/3,O=D+1,L=(N-2)/3,k=L-1,S[B++]=L,S[B++]=k,S[B++]=D,S[B++]=O,H+=3,N-=3}let M=0,R=o[M++],U=o[M++];for(w.set(R,H),w.set(U,N-U.length+1),b=U.length-3,i.push(H/3,(N-2)/3),g=0;g<b;g+=3)D=H/3,O=D+1,L=(N-2)/3,k=L-1,S[B++]=L,S[B++]=k,S[B++]=D,S[B++]=O,H+=3,N-=3;for(g=0;g<p.length;g++){let e;y=p[g];const n=y.leftPositions,d=y.rightPositions;let u,c=P;if(l.defined(n)){for(N-=3,u=k,i.push(O),e=0;e<n.length/3;e++)c=r.Cartesian3.fromArray(n,3*e,c),S[B++]=u-e-1,S[B++]=u-e,a.CorridorGeometryLibrary.addAttribute(w,c,void 0,N),N-=3;i.push(u-Math.floor(n.length/6)),t===s.CornerType.BEVELED&&i.push((N-2)/3+1),H+=3}else{for(H+=3,u=O,i.push(k),e=0;e<d.length/3;e++)c=r.Cartesian3.fromArray(d,3*e,c),S[B++]=u+e,S[B++]=u+e+1,a.CorridorGeometryLibrary.addAttribute(w,c,H),H+=3;i.push(u+Math.floor(d.length/6)),t===s.CornerType.BEVELED&&i.push(H/3-1),N-=3}for(R=o[M++],U=o[M++],R.splice(0,3),U.splice(U.length-3,3),w.set(R,H),w.set(U,N-U.length+1),b=U.length-3,e=0;e<U.length;e+=3)O=H/3,D=O-1,k=(N-2)/3,L=k+1,S[B++]=L,S[B++]=k,S[B++]=D,S[B++]=O,H+=3,N-=3;H-=3,N+=3,i.push(H/3,(N-2)/3)}if(C){H+=3,N-=3,V=G,x=T;const e=f[1];for(g=0;g<I;g++)V=r.Cartesian3.fromArray(e,3*(E-g-1),V),x=r.Cartesian3.fromArray(e,3*g,x),a.CorridorGeometryLibrary.addAttribute(w,V,void 0,N),a.CorridorGeometryLibrary.addAttribute(w,x,H),O=H/3,D=O-1,k=(N-2)/3,L=k+1,S[B++]=L,S[B++]=k,S[B++]=D,S[B++]=O,H+=3,N-=3;i.push(H/3)}else i.push(H/3,(N-2)/3);return S[B++]=H/3,S[B++]=(N-2)/3,h.position=new d.GeometryAttribute({componentDatatype:n.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:w}),{attributes:h,indices:S,wallIndices:i}}function L(t){const i=t.ellipsoid,r=a.CorridorGeometryLibrary.computePositions(t),o=w(r,t.cornerType),s=o.wallIndices,u=t.height,f=t.extrudedHeight,h=o.attributes,y=o.indices;let g=h.position.values,b=g.length,m=new Float64Array(b);m.set(g);const A=new Float64Array(2*b);if(g=p.PolygonPipeline.scaleToGeodeticHeight(g,u,i),m=p.PolygonPipeline.scaleToGeodeticHeight(m,f,i),A.set(g),A.set(m,b),h.position.values=A,b/=3,l.defined(t.offsetAttribute)){let i=new Uint8Array(2*b);if(t.offsetAttribute===e.GeometryOffsetAttribute.TOP)i=e.arrayFill(i,1,0,b);else{const r=t.offsetAttribute===e.GeometryOffsetAttribute.NONE?0:1;i=e.arrayFill(i,r)}h.applyOffset=new d.GeometryAttribute({componentDatatype:n.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:i})}let _;const C=y.length,E=c.IndexDatatype.createTypedArray(A.length/3,2*(C+s.length));E.set(y);let G,T,P=C;for(_=0;_<C;_+=2){const e=y[_],t=y[_+1];E[P++]=e+b,E[P++]=t+b}for(_=0;_<s.length;_++)G=s[_],T=G+b,E[P++]=G,E[P++]=T;return{attributes:h,indices:E}}function D(e){e=l.defaultValue(e,l.defaultValue.EMPTY_OBJECT);const t=e.positions,i=e.width;o.Check.typeOf.object("options.positions",t),o.Check.typeOf.number("options.width",i);const a=l.defaultValue(e.height,0),d=l.defaultValue(e.extrudedHeight,a);this._positions=t,this._ellipsoid=r.Ellipsoid.clone(l.defaultValue(e.ellipsoid,r.Ellipsoid.WGS84)),this._width=i,this._height=Math.max(a,d),this._extrudedHeight=Math.min(a,d),this._cornerType=l.defaultValue(e.cornerType,s.CornerType.ROUNDED),this._granularity=l.defaultValue(e.granularity,n.CesiumMath.RADIANS_PER_DEGREE),this._offsetAttribute=e.offsetAttribute,this._workerName="createCorridorOutlineGeometry",this.packedLength=1+t.length*r.Cartesian3.packedLength+r.Ellipsoid.packedLength+6}D.pack=function(e,t,i){o.Check.typeOf.object("value",e),o.Check.typeOf.object("array",t),i=l.defaultValue(i,0);const n=e._positions,s=n.length;t[i++]=s;for(let o=0;o<s;++o,i+=r.Cartesian3.packedLength)r.Cartesian3.pack(n[o],t,i);return r.Ellipsoid.pack(e._ellipsoid,t,i),i+=r.Ellipsoid.packedLength,t[i++]=e._width,t[i++]=e._height,t[i++]=e._extrudedHeight,t[i++]=e._cornerType,t[i++]=e._granularity,t[i]=l.defaultValue(e._offsetAttribute,-1),t};const k=r.Ellipsoid.clone(r.Ellipsoid.UNIT_SPHERE),O={positions:void 0,ellipsoid:k,width:void 0,height:void 0,extrudedHeight:void 0,cornerType:void 0,granularity:void 0,offsetAttribute:void 0};function x(e,t){return l.defined(t)&&(e=D.unpack(e,t)),e._ellipsoid=r.Ellipsoid.clone(e._ellipsoid),D.createGeometry(e)}return D.unpack=function(e,t,i){o.Check.typeOf.object("array",e),t=l.defaultValue(t,0);const n=e[t++],s=new Array(n);for(let o=0;o<n;++o,t+=r.Cartesian3.packedLength)s[o]=r.Cartesian3.unpack(e,t);const a=r.Ellipsoid.unpack(e,t,k);t+=r.Ellipsoid.packedLength;const d=e[t++],u=e[t++],c=e[t++],p=e[t++],f=e[t++],h=e[t];return l.defined(i)?(i._positions=s,i._ellipsoid=r.Ellipsoid.clone(a,i._ellipsoid),i._width=d,i._height=u,i._extrudedHeight=c,i._cornerType=p,i._granularity=f,i._offsetAttribute=-1===h?void 0:h,i):(O.positions=s,O.width=d,O.height=u,O.extrudedHeight=c,O.cornerType=p,O.granularity=f,O.offsetAttribute=-1===h?void 0:h,new D(O))},D.createGeometry=function(o){let s=o._positions;const u=o._width,c=o._ellipsoid;s=v(s,c);const f=t.arrayRemoveDuplicates(s,r.Cartesian3.equalsEpsilon);if(f.length<2||u<=0)return;const h=o._height,y=o._extrudedHeight,g=!n.CesiumMath.equalsEpsilon(h,y,0,n.CesiumMath.EPSILON2),b={ellipsoid:c,positions:f,width:u,cornerType:o._cornerType,granularity:o._granularity,saveAttributes:!1};let m;if(g)b.height=h,b.extrudedHeight=y,b.offsetAttribute=o._offsetAttribute,m=L(b);else{const t=a.CorridorGeometryLibrary.computePositions(b);if(m=w(t,b.cornerType),m.attributes.position.values=p.PolygonPipeline.scaleToGeodeticHeight(m.attributes.position.values,h,c),l.defined(o._offsetAttribute)){const t=m.attributes.position.values.length,i=new Uint8Array(t/3),r=o._offsetAttribute===e.GeometryOffsetAttribute.NONE?0:1;e.arrayFill(i,r),m.attributes.applyOffset=new d.GeometryAttribute({componentDatatype:n.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:i})}}const A=m.attributes,_=i.BoundingSphere.fromVertices(A.position.values,void 0,3);return new d.Geometry({attributes:A,indices:m.indices,primitiveType:d.PrimitiveType.LINES,boundingSphere:_,offsetAttribute:o._offsetAttribute})},x}));