define(["./defaultValue-94c3e563","./Matrix2-fc7e9822","./GeometryOffsetAttribute-3e8c299c","./Transforms-a076dbe6","./RuntimeError-c581ca93","./ComponentDatatype-4a60b8d6","./GeometryAttribute-2ecf73f6","./GeometryAttributes-7df9bef6","./GeometryInstance-97bd792f","./GeometryPipeline-b4816e69","./IndexDatatype-db156785","./PolygonPipeline-cc031b9f","./RectangleGeometryLibrary-36556359","./VertexFormat-e46f29d6","./_commonjsHelpers-3aae1032-f55dc0c4","./combine-761d9c3f","./WebGLConstants-7dccdc96","./AttributeCompression-4d18cc04","./EncodedCartesian3-d3e254ea","./IntersectionTests-5deed78b","./Plane-e20fba8c","./EllipsoidRhumbLine-daebc75b"],(function(t,e,n,a,o,r,i,s,l,c,u,m,d,p,g,y,f,h,b,_,A,w){"use strict";const x=new e.Cartesian3,C=new e.Cartesian3,v=new e.Cartesian3,R=new e.Cartesian3,E=new e.Rectangle,F=new e.Cartesian2,G=new a.BoundingSphere,P=new a.BoundingSphere;function V(t,e){const n=new i.Geometry({attributes:new s.GeometryAttributes,primitiveType:i.PrimitiveType.TRIANGLES});return n.attributes.position=new i.GeometryAttribute({componentDatatype:r.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:e.positions}),t.normal&&(n.attributes.normal=new i.GeometryAttribute({componentDatatype:r.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:e.normals})),t.tangent&&(n.attributes.tangent=new i.GeometryAttribute({componentDatatype:r.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:e.tangents})),t.bitangent&&(n.attributes.bitangent=new i.GeometryAttribute({componentDatatype:r.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:e.bitangents})),n}function D(t,n,a,o){const r=t.length,i=n.normal?new Float32Array(r):void 0,s=n.tangent?new Float32Array(r):void 0,l=n.bitangent?new Float32Array(r):void 0;let c=0;const u=R,m=v;let d=C;if(n.normal||n.tangent||n.bitangent)for(let p=0;p<r;p+=3){const r=e.Cartesian3.fromArray(t,p,x),g=c+1,y=c+2;d=a.geodeticSurfaceNormal(r,d),(n.tangent||n.bitangent)&&(e.Cartesian3.cross(e.Cartesian3.UNIT_Z,d,m),e.Matrix3.multiplyByVector(o,m,m),e.Cartesian3.normalize(m,m),n.bitangent&&e.Cartesian3.normalize(e.Cartesian3.cross(d,m,u),u)),n.normal&&(i[c]=d.x,i[g]=d.y,i[y]=d.z),n.tangent&&(s[c]=m.x,s[g]=m.y,s[y]=m.z),n.bitangent&&(l[c]=u.x,l[g]=u.y,l[y]=u.z),c+=3}return V(n,{positions:t,normals:i,tangents:s,bitangents:l})}const L=new e.Cartesian3,M=new e.Cartesian3;function O(t,n,a){const o=t.length,i=n.normal?new Float32Array(o):void 0,s=n.tangent?new Float32Array(o):void 0,l=n.bitangent?new Float32Array(o):void 0;let c=0,u=0,m=0,d=!0,p=R,g=v,y=C;if(n.normal||n.tangent||n.bitangent)for(let f=0;f<o;f+=6){const h=e.Cartesian3.fromArray(t,f,x),b=e.Cartesian3.fromArray(t,(f+6)%o,L);if(d){const n=e.Cartesian3.fromArray(t,(f+3)%o,M);e.Cartesian3.subtract(b,h,b),e.Cartesian3.subtract(n,h,n),y=e.Cartesian3.normalize(e.Cartesian3.cross(n,b,y),y),d=!1}e.Cartesian3.equalsEpsilon(b,h,r.CesiumMath.EPSILON10)&&(d=!0),(n.tangent||n.bitangent)&&(p=a.geodeticSurfaceNormal(h,p),n.tangent&&(g=e.Cartesian3.normalize(e.Cartesian3.cross(p,y,g),g))),n.normal&&(i[c++]=y.x,i[c++]=y.y,i[c++]=y.z,i[c++]=y.x,i[c++]=y.y,i[c++]=y.z),n.tangent&&(s[u++]=g.x,s[u++]=g.y,s[u++]=g.z,s[u++]=g.x,s[u++]=g.y,s[u++]=g.z),n.bitangent&&(l[m++]=p.x,l[m++]=p.y,l[m++]=p.z,l[m++]=p.x,l[m++]=p.y,l[m++]=p.z)}return V(n,{positions:t,normals:i,tangents:s,bitangents:l})}function T(t,e){const n=t._vertexFormat,a=t._ellipsoid,o=e.height,s=e.width,l=e.northCap,c=e.southCap;let m=0,p=o,g=o,y=0;l&&(m=1,g-=1,y+=1),c&&(p-=1,g-=1,y+=1),y+=s*g;const f=n.position?new Float64Array(3*y):void 0,h=n.st?new Float32Array(2*y):void 0;let b=0,_=0;const A=x,w=F;let C=Number.MAX_VALUE,v=Number.MAX_VALUE,R=-Number.MAX_VALUE,E=-Number.MAX_VALUE;for(let r=m;r<p;++r)for(let t=0;t<s;++t)d.RectangleGeometryLibrary.computePosition(e,a,n.st,r,t,A,w),f[b++]=A.x,f[b++]=A.y,f[b++]=A.z,n.st&&(h[_++]=w.x,h[_++]=w.y,C=Math.min(C,w.x),v=Math.min(v,w.y),R=Math.max(R,w.x),E=Math.max(E,w.y));if(l&&(d.RectangleGeometryLibrary.computePosition(e,a,n.st,0,0,A,w),f[b++]=A.x,f[b++]=A.y,f[b++]=A.z,n.st&&(h[_++]=w.x,h[_++]=w.y,C=w.x,v=w.y,R=w.x,E=w.y)),c&&(d.RectangleGeometryLibrary.computePosition(e,a,n.st,o-1,0,A,w),f[b++]=A.x,f[b++]=A.y,f[b]=A.z,n.st&&(h[_++]=w.x,h[_]=w.y,C=Math.min(C,w.x),v=Math.min(v,w.y),R=Math.max(R,w.x),E=Math.max(E,w.y))),n.st&&(C<0||v<0||R>1||E>1))for(let r=0;r<h.length;r+=2)h[r]=(h[r]-C)/(R-C),h[r+1]=(h[r+1]-v)/(E-v);const G=D(f,n,a,e.tangentRotationMatrix);let P=6*(s-1)*(g-1);l&&(P+=3*(s-1)),c&&(P+=3*(s-1));const V=u.IndexDatatype.createTypedArray(y,P);let L,M=0,O=0;for(L=0;L<g-1;++L){for(let t=0;t<s-1;++t){const t=M,e=t+s,n=e+1,a=t+1;V[O++]=t,V[O++]=e,V[O++]=a,V[O++]=a,V[O++]=e,V[O++]=n,++M}++M}if(l||c){let t=y-1;const e=y-1;let n,a;if(l&&c&&(t=y-2),M=0,l)for(L=0;L<s-1;L++)n=M,a=n+1,V[O++]=t,V[O++]=n,V[O++]=a,++M;if(c)for(M=(g-1)*s,L=0;L<s-1;L++)n=M,a=n+1,V[O++]=n,V[O++]=e,V[O++]=a,++M}return G.indices=V,n.st&&(G.attributes.st=new i.GeometryAttribute({componentDatatype:r.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:h})),G}function N(t,e,n,a,o){return t[e++]=a[n],t[e++]=a[n+1],t[e++]=a[n+2],t[e++]=o[n],t[e++]=o[n+1],t[e]=o[n+2],t}function k(t,e,n,a){return t[e++]=a[n],t[e++]=a[n+1],t[e++]=a[n],t[e]=a[n+1],t}const S=new p.VertexFormat;function I(a,o){const s=a._shadowVolume,d=a._offsetAttribute,g=a._vertexFormat,y=a._extrudedHeight,f=a._surfaceHeight,h=a._ellipsoid,b=o.height,_=o.width;let A;if(s){const t=p.VertexFormat.clone(g,S);t.normal=!0,a._vertexFormat=t}const w=T(a,o);s&&(a._vertexFormat=g);let x=m.PolygonPipeline.scaleToGeodeticHeight(w.attributes.position.values,f,h,!1);x=new Float64Array(x);let C=x.length;const v=2*C,R=new Float64Array(v);R.set(x);const E=m.PolygonPipeline.scaleToGeodeticHeight(w.attributes.position.values,y,h);R.set(E,C),w.attributes.position.values=R;const F=g.normal?new Float32Array(v):void 0,G=g.tangent?new Float32Array(v):void 0,P=g.bitangent?new Float32Array(v):void 0,V=g.st?new Float32Array(v/3*2):void 0;let D,I,H;if(g.normal){for(I=w.attributes.normal.values,F.set(I),A=0;A<C;A++)I[A]=-I[A];F.set(I,C),w.attributes.normal.values=F}if(s){I=w.attributes.normal.values,g.normal||(w.attributes.normal=void 0);const t=new Float32Array(v);for(A=0;A<C;A++)I[A]=-I[A];t.set(I,C),w.attributes.extrudeDirection=new i.GeometryAttribute({componentDatatype:r.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:t})}const z=t.defined(d);if(z){const t=C/3*2;let e=new Uint8Array(t);d===n.GeometryOffsetAttribute.TOP?e=n.arrayFill(e,1,0,t/2):(H=d===n.GeometryOffsetAttribute.NONE?0:1,e=n.arrayFill(e,H)),w.attributes.applyOffset=new i.GeometryAttribute({componentDatatype:r.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:e})}if(g.tangent){const t=w.attributes.tangent.values;for(G.set(t),A=0;A<C;A++)t[A]=-t[A];G.set(t,C),w.attributes.tangent.values=G}if(g.bitangent){const t=w.attributes.bitangent.values;P.set(t),P.set(t,C),w.attributes.bitangent.values=P}g.st&&(D=w.attributes.st.values,V.set(D),V.set(D,C/3*2),w.attributes.st.values=V);const B=w.indices,U=B.length,q=C/3,Y=u.IndexDatatype.createTypedArray(v/3,2*U);for(Y.set(B),A=0;A<U;A+=3)Y[A+U]=B[A+2]+q,Y[A+1+U]=B[A+1]+q,Y[A+2+U]=B[A]+q;w.indices=Y;const j=o.northCap,X=o.southCap;let Q=b,W=2,J=0,Z=4,K=4;j&&(W-=1,Q-=1,J+=1,Z-=2,K-=1),X&&(W-=1,Q-=1,J+=1,Z-=2,K-=1),J+=W*_+2*Q-Z;const $=2*(J+K);let tt=new Float64Array(3*$);const et=s?new Float32Array(3*$):void 0;let nt=z?new Uint8Array($):void 0,at=g.st?new Float32Array(2*$):void 0;const ot=d===n.GeometryOffsetAttribute.TOP;z&&!ot&&(H=d===n.GeometryOffsetAttribute.ALL?1:0,nt=n.arrayFill(nt,H));let rt=0,it=0,st=0,lt=0;const ct=_*Q;let ut;for(A=0;A<ct;A+=_)ut=3*A,tt=N(tt,rt,ut,x,E),rt+=6,g.st&&(at=k(at,it,2*A,D),it+=4),s&&(st+=3,et[st++]=I[ut],et[st++]=I[ut+1],et[st++]=I[ut+2]),ot&&(nt[lt++]=1,lt+=1);if(X){const t=j?ct+1:ct;for(ut=3*t,A=0;A<2;A++)tt=N(tt,rt,ut,x,E),rt+=6,g.st&&(at=k(at,it,2*t,D),it+=4),s&&(st+=3,et[st++]=I[ut],et[st++]=I[ut+1],et[st++]=I[ut+2]),ot&&(nt[lt++]=1,lt+=1)}else for(A=ct-_;A<ct;A++)ut=3*A,tt=N(tt,rt,ut,x,E),rt+=6,g.st&&(at=k(at,it,2*A,D),it+=4),s&&(st+=3,et[st++]=I[ut],et[st++]=I[ut+1],et[st++]=I[ut+2]),ot&&(nt[lt++]=1,lt+=1);for(A=ct-1;A>0;A-=_)ut=3*A,tt=N(tt,rt,ut,x,E),rt+=6,g.st&&(at=k(at,it,2*A,D),it+=4),s&&(st+=3,et[st++]=I[ut],et[st++]=I[ut+1],et[st++]=I[ut+2]),ot&&(nt[lt++]=1,lt+=1);if(j){const t=ct;for(ut=3*t,A=0;A<2;A++)tt=N(tt,rt,ut,x,E),rt+=6,g.st&&(at=k(at,it,2*t,D),it+=4),s&&(st+=3,et[st++]=I[ut],et[st++]=I[ut+1],et[st++]=I[ut+2]),ot&&(nt[lt++]=1,lt+=1)}else for(A=_-1;A>=0;A--)ut=3*A,tt=N(tt,rt,ut,x,E),rt+=6,g.st&&(at=k(at,it,2*A,D),it+=4),s&&(st+=3,et[st++]=I[ut],et[st++]=I[ut+1],et[st++]=I[ut+2]),ot&&(nt[lt++]=1,lt+=1);let mt=O(tt,g,h);g.st&&(mt.attributes.st=new i.GeometryAttribute({componentDatatype:r.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:at})),s&&(mt.attributes.extrudeDirection=new i.GeometryAttribute({componentDatatype:r.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:et})),z&&(mt.attributes.applyOffset=new i.GeometryAttribute({componentDatatype:r.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:nt}));const dt=u.IndexDatatype.createTypedArray($,6*J);let pt,gt,yt,ft;C=tt.length/3;let ht=0;for(A=0;A<C-1;A+=2){pt=A,ft=(pt+2)%C;const t=e.Cartesian3.fromArray(tt,3*pt,L),n=e.Cartesian3.fromArray(tt,3*ft,M);e.Cartesian3.equalsEpsilon(t,n,r.CesiumMath.EPSILON10)||(gt=(pt+1)%C,yt=(gt+2)%C,dt[ht++]=pt,dt[ht++]=gt,dt[ht++]=ft,dt[ht++]=ft,dt[ht++]=gt,dt[ht++]=yt)}return mt.indices=dt,mt=c.GeometryPipeline.combineInstances([new l.GeometryInstance({geometry:w}),new l.GeometryInstance({geometry:mt})]),mt[0]}const H=[new e.Cartesian3,new e.Cartesian3,new e.Cartesian3,new e.Cartesian3],z=new e.Cartographic,B=new e.Cartographic;function U(t,n,a,o,r){if(0===a)return e.Rectangle.clone(t,r);const i=d.RectangleGeometryLibrary.computeOptions(t,n,a,0,E,z),s=i.height,l=i.width,c=H;return d.RectangleGeometryLibrary.computePosition(i,o,!1,0,0,c[0]),d.RectangleGeometryLibrary.computePosition(i,o,!1,0,l-1,c[1]),d.RectangleGeometryLibrary.computePosition(i,o,!1,s-1,0,c[2]),d.RectangleGeometryLibrary.computePosition(i,o,!1,s-1,l-1,c[3]),e.Rectangle.fromCartesianArray(c,o,r)}function q(n){n=t.defaultValue(n,t.defaultValue.EMPTY_OBJECT);const a=n.rectangle;if(o.Check.typeOf.object("rectangle",a),e.Rectangle.validate(a),a.north<a.south)throw new o.DeveloperError("options.rectangle.north must be greater than or equal to options.rectangle.south");const i=t.defaultValue(n.height,0),s=t.defaultValue(n.extrudedHeight,i);this._rectangle=e.Rectangle.clone(a),this._granularity=t.defaultValue(n.granularity,r.CesiumMath.RADIANS_PER_DEGREE),this._ellipsoid=e.Ellipsoid.clone(t.defaultValue(n.ellipsoid,e.Ellipsoid.WGS84)),this._surfaceHeight=Math.max(i,s),this._rotation=t.defaultValue(n.rotation,0),this._stRotation=t.defaultValue(n.stRotation,0),this._vertexFormat=p.VertexFormat.clone(t.defaultValue(n.vertexFormat,p.VertexFormat.DEFAULT)),this._extrudedHeight=Math.min(i,s),this._shadowVolume=t.defaultValue(n.shadowVolume,!1),this._workerName="createRectangleGeometry",this._offsetAttribute=n.offsetAttribute,this._rotatedRectangle=void 0,this._textureCoordinateRotationPoints=void 0}q.packedLength=e.Rectangle.packedLength+e.Ellipsoid.packedLength+p.VertexFormat.packedLength+7,q.pack=function(n,a,r){return o.Check.typeOf.object("value",n),o.Check.defined("array",a),r=t.defaultValue(r,0),e.Rectangle.pack(n._rectangle,a,r),r+=e.Rectangle.packedLength,e.Ellipsoid.pack(n._ellipsoid,a,r),r+=e.Ellipsoid.packedLength,p.VertexFormat.pack(n._vertexFormat,a,r),r+=p.VertexFormat.packedLength,a[r++]=n._granularity,a[r++]=n._surfaceHeight,a[r++]=n._rotation,a[r++]=n._stRotation,a[r++]=n._extrudedHeight,a[r++]=n._shadowVolume?1:0,a[r]=t.defaultValue(n._offsetAttribute,-1),a};const Y=new e.Rectangle,j=e.Ellipsoid.clone(e.Ellipsoid.UNIT_SPHERE),X={rectangle:Y,ellipsoid:j,vertexFormat:S,granularity:void 0,height:void 0,rotation:void 0,stRotation:void 0,extrudedHeight:void 0,shadowVolume:void 0,offsetAttribute:void 0};q.unpack=function(n,a,r){o.Check.defined("array",n),a=t.defaultValue(a,0);const i=e.Rectangle.unpack(n,a,Y);a+=e.Rectangle.packedLength;const s=e.Ellipsoid.unpack(n,a,j);a+=e.Ellipsoid.packedLength;const l=p.VertexFormat.unpack(n,a,S);a+=p.VertexFormat.packedLength;const c=n[a++],u=n[a++],m=n[a++],d=n[a++],g=n[a++],y=1===n[a++],f=n[a];return t.defined(r)?(r._rectangle=e.Rectangle.clone(i,r._rectangle),r._ellipsoid=e.Ellipsoid.clone(s,r._ellipsoid),r._vertexFormat=p.VertexFormat.clone(l,r._vertexFormat),r._granularity=c,r._surfaceHeight=u,r._rotation=m,r._stRotation=d,r._extrudedHeight=g,r._shadowVolume=y,r._offsetAttribute=-1===f?void 0:f,r):(X.granularity=c,X.height=u,X.rotation=m,X.stRotation=d,X.extrudedHeight=g,X.shadowVolume=y,X.offsetAttribute=-1===f?void 0:f,new q(X))},q.computeRectangle=function(n,a){n=t.defaultValue(n,t.defaultValue.EMPTY_OBJECT);const i=n.rectangle;if(o.Check.typeOf.object("rectangle",i),e.Rectangle.validate(i),i.north<i.south)throw new o.DeveloperError("options.rectangle.north must be greater than or equal to options.rectangle.south");const s=t.defaultValue(n.granularity,r.CesiumMath.RADIANS_PER_DEGREE),l=t.defaultValue(n.ellipsoid,e.Ellipsoid.WGS84),c=t.defaultValue(n.rotation,0);return U(i,s,c,l,a)};const Q=new e.Matrix3,W=new a.Quaternion,J=new e.Cartographic;q.createGeometry=function(o){if(r.CesiumMath.equalsEpsilon(o._rectangle.north,o._rectangle.south,r.CesiumMath.EPSILON10)||r.CesiumMath.equalsEpsilon(o._rectangle.east,o._rectangle.west,r.CesiumMath.EPSILON10))return;let s=o._rectangle;const l=o._ellipsoid,c=o._rotation,u=o._stRotation,p=o._vertexFormat,g=d.RectangleGeometryLibrary.computeOptions(s,o._granularity,c,u,E,z,B),y=Q;if(0!==u||0!==c){const t=e.Rectangle.center(s,J),n=l.geodeticSurfaceNormalCartographic(t,L);a.Quaternion.fromAxisAngle(n,-u,W),e.Matrix3.fromQuaternion(W,y)}else e.Matrix3.clone(e.Matrix3.IDENTITY,y);const f=o._surfaceHeight,h=o._extrudedHeight,b=!r.CesiumMath.equalsEpsilon(f,h,0,r.CesiumMath.EPSILON2);let _,A;if(g.lonScalar=1/o._rectangle.width,g.latScalar=1/o._rectangle.height,g.tangentRotationMatrix=y,s=o._rectangle,b){_=I(o,g);const t=a.BoundingSphere.fromRectangle3D(s,l,f,P),e=a.BoundingSphere.fromRectangle3D(s,l,h,G);A=a.BoundingSphere.union(t,e)}else{if(_=T(o,g),_.attributes.position.values=m.PolygonPipeline.scaleToGeodeticHeight(_.attributes.position.values,f,l,!1),t.defined(o._offsetAttribute)){const t=_.attributes.position.values.length,e=new Uint8Array(t/3),a=o._offsetAttribute===n.GeometryOffsetAttribute.NONE?0:1;n.arrayFill(e,a),_.attributes.applyOffset=new i.GeometryAttribute({componentDatatype:r.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:e})}A=a.BoundingSphere.fromRectangle3D(s,l,f)}return p.position||delete _.attributes.position,new i.Geometry({attributes:_.attributes,indices:_.indices,primitiveType:_.primitiveType,boundingSphere:A,offsetAttribute:o._offsetAttribute})},q.createShadowVolume=function(t,e,n){const a=t._granularity,o=t._ellipsoid,r=e(a,o),i=n(a,o);return new q({rectangle:t._rectangle,rotation:t._rotation,ellipsoid:o,stRotation:t._stRotation,granularity:a,extrudedHeight:i,height:r,vertexFormat:p.VertexFormat.POSITION_ONLY,shadowVolume:!0})};const Z=new e.Rectangle,K=[new e.Cartesian2,new e.Cartesian2,new e.Cartesian2],$=new e.Matrix2,tt=new e.Cartographic;function et(t){if(0===t._stRotation)return[0,0,0,1,1,0];const n=e.Rectangle.clone(t._rectangle,Z),a=t._granularity,o=t._ellipsoid,r=t._rotation-t._stRotation,i=U(n,a,r,o,Z),s=K;s[0].x=i.west,s[0].y=i.south,s[1].x=i.west,s[1].y=i.north,s[2].x=i.east,s[2].y=i.south;const l=t.rectangle,c=e.Matrix2.fromRotation(t._stRotation,$),u=e.Rectangle.center(l,tt);for(let y=0;y<3;++y){const t=s[y];t.x-=u.longitude,t.y-=u.latitude,e.Matrix2.multiplyByVector(c,t,t),t.x+=u.longitude,t.y+=u.latitude,t.x=(t.x-l.west)/l.width,t.y=(t.y-l.south)/l.height}const m=s[0],d=s[1],p=s[2],g=new Array(6);return e.Cartesian2.pack(m,g),e.Cartesian2.pack(d,g,2),e.Cartesian2.pack(p,g,4),g}function nt(n,a){return t.defined(a)&&(n=q.unpack(n,a)),n._ellipsoid=e.Ellipsoid.clone(n._ellipsoid),n._rectangle=e.Rectangle.clone(n._rectangle),q.createGeometry(n)}return Object.defineProperties(q.prototype,{rectangle:{get:function(){return t.defined(this._rotatedRectangle)||(this._rotatedRectangle=U(this._rectangle,this._granularity,this._rotation,this._ellipsoid)),this._rotatedRectangle}},textureCoordinateRotationPoints:{get:function(){return t.defined(this._textureCoordinateRotationPoints)||(this._textureCoordinateRotationPoints=et(this)),this._textureCoordinateRotationPoints}}}),nt}));