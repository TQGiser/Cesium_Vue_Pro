define(["exports","./Matrix2-fc7e9822","./ComponentDatatype-4a60b8d6","./Transforms-a076dbe6"],(function(t,a,e,n){"use strict";const i={},r=new a.Cartesian3,s=new a.Cartesian3,o=new n.Quaternion,l=new a.Matrix3;function c(t,e,i,c,C,y,u,m,h,x){const M=t+e;a.Cartesian3.multiplyByScalar(c,Math.cos(M),r),a.Cartesian3.multiplyByScalar(i,Math.sin(M),s),a.Cartesian3.add(r,s,r);let f=Math.cos(t);f*=f;let z=Math.sin(t);z*=z;const d=y/Math.sqrt(u*f+C*z),_=d/m;return n.Quaternion.fromAxisAngle(r,_,o),a.Matrix3.fromQuaternion(o,l),a.Matrix3.multiplyByVector(l,h,x),a.Cartesian3.normalize(x,x),a.Cartesian3.multiplyByScalar(x,m,x),x}const C=new a.Cartesian3,y=new a.Cartesian3,u=new a.Cartesian3,m=new a.Cartesian3;i.raisePositionsToHeight=function(t,e,n){const i=e.ellipsoid,r=e.height,s=e.extrudedHeight,o=n?t.length/3*2:t.length/3,l=new Float64Array(3*o),c=t.length,h=n?c:0;for(let x=0;x<c;x+=3){const e=x+1,o=x+2,c=a.Cartesian3.fromArray(t,x,C);i.scaleToGeodeticSurface(c,c);const M=a.Cartesian3.clone(c,y),f=i.geodeticSurfaceNormal(c,m),z=a.Cartesian3.multiplyByScalar(f,r,u);a.Cartesian3.add(c,z,c),n&&(a.Cartesian3.multiplyByScalar(f,s,z),a.Cartesian3.add(M,z,M),l[x+h]=M.x,l[e+h]=M.y,l[o+h]=M.z),l[x]=c.x,l[e]=c.y,l[o]=c.z}return l};const h=new a.Cartesian3,x=new a.Cartesian3,M=new a.Cartesian3;i.computeEllipsePositions=function(t,n,i){const r=t.semiMinorAxis,s=t.semiMajorAxis,o=t.rotation,l=t.center,m=8*t.granularity,f=r*r,z=s*s,d=s*r,_=a.Cartesian3.magnitude(l),p=a.Cartesian3.normalize(l,h);let O=a.Cartesian3.cross(a.Cartesian3.UNIT_Z,l,x);O=a.Cartesian3.normalize(O,O);const w=a.Cartesian3.cross(p,O,M);let P=1+Math.ceil(e.CesiumMath.PI_OVER_TWO/m);const T=e.CesiumMath.PI_OVER_TWO/(P-1);let I=e.CesiumMath.PI_OVER_TWO-P*T;I<0&&(P-=Math.ceil(Math.abs(I)/T));const g=P*(P+2)*2,E=n?new Array(3*g):void 0;let V=0,A=C,R=y;const W=4*P*3;let S=W-1,B=0;const b=i?new Array(W):void 0;let Q,v,G,H,N;for(I=e.CesiumMath.PI_OVER_TWO,A=c(I,o,w,O,f,d,z,_,p,A),n&&(E[V++]=A.x,E[V++]=A.y,E[V++]=A.z),i&&(b[S--]=A.z,b[S--]=A.y,b[S--]=A.x),I=e.CesiumMath.PI_OVER_TWO-T,Q=1;Q<P+1;++Q){if(A=c(I,o,w,O,f,d,z,_,p,A),R=c(Math.PI-I,o,w,O,f,d,z,_,p,R),n){for(E[V++]=A.x,E[V++]=A.y,E[V++]=A.z,G=2*Q+2,v=1;v<G-1;++v)H=v/(G-1),N=a.Cartesian3.lerp(A,R,H,u),E[V++]=N.x,E[V++]=N.y,E[V++]=N.z;E[V++]=R.x,E[V++]=R.y,E[V++]=R.z}i&&(b[S--]=A.z,b[S--]=A.y,b[S--]=A.x,b[B++]=R.x,b[B++]=R.y,b[B++]=R.z),I=e.CesiumMath.PI_OVER_TWO-(Q+1)*T}for(Q=P;Q>1;--Q){if(I=e.CesiumMath.PI_OVER_TWO-(Q-1)*T,A=c(-I,o,w,O,f,d,z,_,p,A),R=c(I+Math.PI,o,w,O,f,d,z,_,p,R),n){for(E[V++]=A.x,E[V++]=A.y,E[V++]=A.z,G=2*(Q-1)+2,v=1;v<G-1;++v)H=v/(G-1),N=a.Cartesian3.lerp(A,R,H,u),E[V++]=N.x,E[V++]=N.y,E[V++]=N.z;E[V++]=R.x,E[V++]=R.y,E[V++]=R.z}i&&(b[S--]=A.z,b[S--]=A.y,b[S--]=A.x,b[B++]=R.x,b[B++]=R.y,b[B++]=R.z)}I=e.CesiumMath.PI_OVER_TWO,A=c(-I,o,w,O,f,d,z,_,p,A);const j={};return n&&(E[V++]=A.x,E[V++]=A.y,E[V++]=A.z,j.positions=E,j.numPts=P),i&&(b[S--]=A.z,b[S--]=A.y,b[S--]=A.x,j.outerPositions=b),j},t.EllipseGeometryLibrary=i}));