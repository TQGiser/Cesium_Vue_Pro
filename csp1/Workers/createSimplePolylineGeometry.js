define(["./defaultValue-94c3e563","./Matrix2-fc7e9822","./ArcType-0cf52f8c","./Transforms-a076dbe6","./Color-ec9112c4","./ComponentDatatype-4a60b8d6","./RuntimeError-c581ca93","./GeometryAttribute-2ecf73f6","./GeometryAttributes-7df9bef6","./IndexDatatype-db156785","./PolylinePipeline-7608e667","./_commonjsHelpers-3aae1032-f55dc0c4","./combine-761d9c3f","./WebGLConstants-7dccdc96","./EllipsoidGeodesic-dc94f381","./EllipsoidRhumbLine-daebc75b","./IntersectionTests-5deed78b","./Plane-e20fba8c"],(function(e,o,t,r,l,n,i,a,s,c,d,p,f,u,y,h,C,g){"use strict";function m(e,o,t,r,n,i,a){const s=d.PolylinePipeline.numberOfPoints(e,o,n);let c;const p=t.red,f=t.green,u=t.blue,y=t.alpha,h=r.red,C=r.green,g=r.blue,m=r.alpha;if(l.Color.equals(t,r)){for(c=0;c<s;c++)i[a++]=l.Color.floatToByte(p),i[a++]=l.Color.floatToByte(f),i[a++]=l.Color.floatToByte(u),i[a++]=l.Color.floatToByte(y);return a}const T=(h-p)/s,E=(C-f)/s,b=(g-u)/s,_=(m-y)/s;let P=a;for(c=0;c<s;c++)i[P++]=l.Color.floatToByte(p+c*T),i[P++]=l.Color.floatToByte(f+c*E),i[P++]=l.Color.floatToByte(u+c*b),i[P++]=l.Color.floatToByte(y+c*_);return P}function T(r){r=e.defaultValue(r,e.defaultValue.EMPTY_OBJECT);const a=r.positions,s=r.colors,c=e.defaultValue(r.colorsPerVertex,!1);if(!e.defined(a)||a.length<2)throw new i.DeveloperError("At least two positions are required.");if(e.defined(s)&&(c&&s.length<a.length||!c&&s.length<a.length-1))throw new i.DeveloperError("colors has an invalid length.");this._positions=a,this._colors=s,this._colorsPerVertex=c,this._arcType=e.defaultValue(r.arcType,t.ArcType.GEODESIC),this._granularity=e.defaultValue(r.granularity,n.CesiumMath.RADIANS_PER_DEGREE),this._ellipsoid=e.defaultValue(r.ellipsoid,o.Ellipsoid.WGS84),this._workerName="createSimplePolylineGeometry";let d=1+a.length*o.Cartesian3.packedLength;d+=e.defined(s)?1+s.length*l.Color.packedLength:1,this.packedLength=d+o.Ellipsoid.packedLength+3}T.pack=function(t,r,n){if(!e.defined(t))throw new i.DeveloperError("value is required");if(!e.defined(r))throw new i.DeveloperError("array is required");let a;n=e.defaultValue(n,0);const s=t._positions;let c=s.length;for(r[n++]=c,a=0;a<c;++a,n+=o.Cartesian3.packedLength)o.Cartesian3.pack(s[a],r,n);const d=t._colors;for(c=e.defined(d)?d.length:0,r[n++]=c,a=0;a<c;++a,n+=l.Color.packedLength)l.Color.pack(d[a],r,n);return o.Ellipsoid.pack(t._ellipsoid,r,n),n+=o.Ellipsoid.packedLength,r[n++]=t._colorsPerVertex?1:0,r[n++]=t._arcType,r[n]=t._granularity,r},T.unpack=function(t,r,n){if(!e.defined(t))throw new i.DeveloperError("array is required");let a;r=e.defaultValue(r,0);let s=t[r++];const c=new Array(s);for(a=0;a<s;++a,r+=o.Cartesian3.packedLength)c[a]=o.Cartesian3.unpack(t,r);s=t[r++];const d=s>0?new Array(s):void 0;for(a=0;a<s;++a,r+=l.Color.packedLength)d[a]=l.Color.unpack(t,r);const p=o.Ellipsoid.unpack(t,r);r+=o.Ellipsoid.packedLength;const f=1===t[r++],u=t[r++],y=t[r];return e.defined(n)?(n._positions=c,n._colors=d,n._ellipsoid=p,n._colorsPerVertex=f,n._arcType=u,n._granularity=y,n):new T({positions:c,colors:d,ellipsoid:p,colorsPerVertex:f,arcType:u,granularity:y})};const E=new Array(2),b=new Array(2),_={positions:E,height:b,ellipsoid:void 0,minDistance:void 0,granularity:void 0};function P(t,r){return e.defined(r)&&(t=T.unpack(t,r)),t._ellipsoid=o.Ellipsoid.clone(t._ellipsoid),T.createGeometry(t)}return T.createGeometry=function(i){const p=i._positions,f=i._colors,u=i._colorsPerVertex,y=i._arcType,h=i._granularity,C=i._ellipsoid,g=n.CesiumMath.chordLength(h,C.maximumRadius),T=e.defined(f)&&!u;let P;const A=p.length;let B,w,k,D,G=0;if(y===t.ArcType.GEODESIC||y===t.ArcType.RHUMB){let o,r,i;y===t.ArcType.GEODESIC?(o=n.CesiumMath.chordLength(h,C.maximumRadius),r=d.PolylinePipeline.numberOfPoints,i=d.PolylinePipeline.generateArc):(o=h,r=d.PolylinePipeline.numberOfPointsRhumbLine,i=d.PolylinePipeline.generateRhumbArc);const a=d.PolylinePipeline.extractHeights(p,C),s=_;if(y===t.ArcType.GEODESIC?s.minDistance=g:s.granularity=h,s.ellipsoid=C,T){let t=0;for(P=0;P<A-1;P++)t+=r(p[P],p[P+1],o)+1;B=new Float64Array(3*t),k=new Uint8Array(4*t),s.positions=E,s.height=b;let n=0;for(P=0;P<A-1;++P){E[0]=p[P],E[1]=p[P+1],b[0]=a[P],b[1]=a[P+1];const o=i(s);if(e.defined(f)){const e=o.length/3;D=f[P];for(let o=0;o<e;++o)k[n++]=l.Color.floatToByte(D.red),k[n++]=l.Color.floatToByte(D.green),k[n++]=l.Color.floatToByte(D.blue),k[n++]=l.Color.floatToByte(D.alpha)}B.set(o,G),G+=o.length}}else if(s.positions=p,s.height=a,B=new Float64Array(i(s)),e.defined(f)){for(k=new Uint8Array(B.length/3*4),P=0;P<A-1;++P){const e=p[P],o=p[P+1],t=f[P],r=f[P+1];G=m(e,o,t,r,g,k,G)}const e=f[A-1];k[G++]=l.Color.floatToByte(e.red),k[G++]=l.Color.floatToByte(e.green),k[G++]=l.Color.floatToByte(e.blue),k[G++]=l.Color.floatToByte(e.alpha)}}else{w=T?2*A-2:A,B=new Float64Array(3*w),k=e.defined(f)?new Uint8Array(4*w):void 0;let t=0,r=0;for(P=0;P<A;++P){const n=p[P];if(T&&P>0&&(o.Cartesian3.pack(n,B,t),t+=3,D=f[P-1],k[r++]=l.Color.floatToByte(D.red),k[r++]=l.Color.floatToByte(D.green),k[r++]=l.Color.floatToByte(D.blue),k[r++]=l.Color.floatToByte(D.alpha)),T&&P===A-1)break;o.Cartesian3.pack(n,B,t),t+=3,e.defined(f)&&(D=f[P],k[r++]=l.Color.floatToByte(D.red),k[r++]=l.Color.floatToByte(D.green),k[r++]=l.Color.floatToByte(D.blue),k[r++]=l.Color.floatToByte(D.alpha))}}const L=new s.GeometryAttributes;L.position=new a.GeometryAttribute({componentDatatype:n.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:B}),e.defined(f)&&(L.color=new a.GeometryAttribute({componentDatatype:n.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:4,values:k,normalize:!0})),w=B.length/3;const v=2*(w-1),V=c.IndexDatatype.createTypedArray(w,v);let x=0;for(P=0;P<w-1;++P)V[x++]=P,V[x++]=P+1;return new a.Geometry({attributes:L,indices:V,primitiveType:a.PrimitiveType.LINES,boundingSphere:r.BoundingSphere.fromPoints(p)})},P}));