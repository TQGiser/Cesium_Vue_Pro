define(["./GeometryOffsetAttribute-3e8c299c","./arrayRemoveDuplicates-06991c15","./Transforms-a076dbe6","./Matrix2-fc7e9822","./RuntimeError-c581ca93","./ComponentDatatype-4a60b8d6","./PolylineVolumeGeometryLibrary-759a8d46","./CorridorGeometryLibrary-3d47380e","./defaultValue-94c3e563","./GeometryAttribute-2ecf73f6","./GeometryAttributes-7df9bef6","./IndexDatatype-db156785","./PolygonPipeline-cc031b9f","./VertexFormat-e46f29d6","./_commonjsHelpers-3aae1032-f55dc0c4","./combine-761d9c3f","./WebGLConstants-7dccdc96","./EllipsoidTangentPlane-d2c0c530","./AxisAlignedBoundingBox-8103739f","./IntersectionTests-5deed78b","./Plane-e20fba8c","./PolylinePipeline-7608e667","./EllipsoidGeodesic-dc94f381","./EllipsoidRhumbLine-daebc75b"],(function(t,e,r,a,i,o,n,s,l,d,u,c,m,f,y,p,h,g,C,b,A,_,w,v){"use strict";const T=new a.Cartesian3,G=new a.Cartesian3,E=new a.Cartesian3,V=new a.Cartesian3,x=new a.Cartesian3,F=new a.Cartesian3,L=new a.Cartesian3,P=new a.Cartesian3;function N(t,e){for(let r=0;r<t.length;r++)t[r]=e.scaleToGeodeticSurface(t[r],t[r]);return t}function D(t,e,r,i,o,n){const l=t.normals,d=t.tangents,u=t.bitangents,c=a.Cartesian3.normalize(a.Cartesian3.cross(r,e,L),L);n.normal&&s.CorridorGeometryLibrary.addAttribute(l,e,i,o),n.tangent&&s.CorridorGeometryLibrary.addAttribute(d,c,i,o),n.bitangent&&s.CorridorGeometryLibrary.addAttribute(u,r,i,o)}function M(t,e,r){const i=t.positions,n=t.corners,m=t.endPositions,f=t.lefts,y=t.normals,p=new u.GeometryAttributes;let h,g,C,b=0,A=0,_=0;for(g=0;g<i.length;g+=2)C=i[g].length-3,b+=C,_+=2*C,A+=i[g+1].length-3;for(b+=3,A+=3,g=0;g<n.length;g++){h=n[g];const t=n[g].leftPositions;l.defined(t)?(C=t.length,b+=C,_+=C):(C=n[g].rightPositions.length,A+=C,_+=C)}const w=l.defined(m);let v;w&&(v=m[0].length-3,b+=v,A+=v,v/=3,_+=6*v);const x=b+A,N=new Float64Array(x),M=e.normal?new Float32Array(x):void 0,O=e.tangent?new Float32Array(x):void 0,I=e.bitangent?new Float32Array(x):void 0,k={normals:M,tangents:O,bitangents:I};let S,R,H,z,B,U,Y=0,W=x-1,q=T,j=G;const J=v/2,K=c.IndexDatatype.createTypedArray(x/3,_);let Q=0;if(w){U=E,B=V;const t=m[0];for(q=a.Cartesian3.fromArray(y,0,q),j=a.Cartesian3.fromArray(f,0,j),g=0;g<J;g++)U=a.Cartesian3.fromArray(t,3*(J-1-g),U),B=a.Cartesian3.fromArray(t,3*(J+g),B),s.CorridorGeometryLibrary.addAttribute(N,B,Y),s.CorridorGeometryLibrary.addAttribute(N,U,void 0,W),D(k,q,j,Y,W,e),R=Y/3,z=R+1,S=(W-2)/3,H=S-1,K[Q++]=S,K[Q++]=R,K[Q++]=H,K[Q++]=H,K[Q++]=R,K[Q++]=z,Y+=3,W-=3}let X,Z,$=0,tt=0,et=i[$++],rt=i[$++];for(N.set(et,Y),N.set(rt,W-rt.length+1),j=a.Cartesian3.fromArray(f,tt,j),C=rt.length-3,g=0;g<C;g+=3)X=r.geodeticSurfaceNormal(a.Cartesian3.fromArray(et,g,L),L),Z=r.geodeticSurfaceNormal(a.Cartesian3.fromArray(rt,C-g,P),P),q=a.Cartesian3.normalize(a.Cartesian3.add(X,Z,q),q),D(k,q,j,Y,W,e),R=Y/3,z=R+1,S=(W-2)/3,H=S-1,K[Q++]=S,K[Q++]=R,K[Q++]=H,K[Q++]=H,K[Q++]=R,K[Q++]=z,Y+=3,W-=3;for(X=r.geodeticSurfaceNormal(a.Cartesian3.fromArray(et,C,L),L),Z=r.geodeticSurfaceNormal(a.Cartesian3.fromArray(rt,C,P),P),q=a.Cartesian3.normalize(a.Cartesian3.add(X,Z,q),q),tt+=3,g=0;g<n.length;g++){let t;h=n[g];const o=h.leftPositions,d=h.rightPositions;let u,c,m=F,p=E,b=V;if(q=a.Cartesian3.fromArray(y,tt,q),l.defined(o)){for(D(k,q,j,void 0,W,e),W-=3,u=z,c=H,t=0;t<o.length/3;t++)m=a.Cartesian3.fromArray(o,3*t,m),K[Q++]=u,K[Q++]=c-t-1,K[Q++]=c-t,s.CorridorGeometryLibrary.addAttribute(N,m,void 0,W),p=a.Cartesian3.fromArray(N,3*(c-t-1),p),b=a.Cartesian3.fromArray(N,3*u,b),j=a.Cartesian3.normalize(a.Cartesian3.subtract(p,b,j),j),D(k,q,j,void 0,W,e),W-=3;m=a.Cartesian3.fromArray(N,3*u,m),p=a.Cartesian3.subtract(a.Cartesian3.fromArray(N,3*c,p),m,p),b=a.Cartesian3.subtract(a.Cartesian3.fromArray(N,3*(c-t),b),m,b),j=a.Cartesian3.normalize(a.Cartesian3.add(p,b,j),j),D(k,q,j,Y,void 0,e),Y+=3}else{for(D(k,q,j,Y,void 0,e),Y+=3,u=H,c=z,t=0;t<d.length/3;t++)m=a.Cartesian3.fromArray(d,3*t,m),K[Q++]=u,K[Q++]=c+t,K[Q++]=c+t+1,s.CorridorGeometryLibrary.addAttribute(N,m,Y),p=a.Cartesian3.fromArray(N,3*u,p),b=a.Cartesian3.fromArray(N,3*(c+t),b),j=a.Cartesian3.normalize(a.Cartesian3.subtract(p,b,j),j),D(k,q,j,Y,void 0,e),Y+=3;m=a.Cartesian3.fromArray(N,3*u,m),p=a.Cartesian3.subtract(a.Cartesian3.fromArray(N,3*(c+t),p),m,p),b=a.Cartesian3.subtract(a.Cartesian3.fromArray(N,3*c,b),m,b),j=a.Cartesian3.normalize(a.Cartesian3.negate(a.Cartesian3.add(b,p,j),j),j),D(k,q,j,void 0,W,e),W-=3}for(et=i[$++],rt=i[$++],et.splice(0,3),rt.splice(rt.length-3,3),N.set(et,Y),N.set(rt,W-rt.length+1),C=rt.length-3,tt+=3,j=a.Cartesian3.fromArray(f,tt,j),t=0;t<rt.length;t+=3)X=r.geodeticSurfaceNormal(a.Cartesian3.fromArray(et,t,L),L),Z=r.geodeticSurfaceNormal(a.Cartesian3.fromArray(rt,C-t,P),P),q=a.Cartesian3.normalize(a.Cartesian3.add(X,Z,q),q),D(k,q,j,Y,W,e),z=Y/3,R=z-1,H=(W-2)/3,S=H+1,K[Q++]=S,K[Q++]=R,K[Q++]=H,K[Q++]=H,K[Q++]=R,K[Q++]=z,Y+=3,W-=3;Y-=3,W+=3}if(q=a.Cartesian3.fromArray(y,y.length-3,q),D(k,q,j,Y,W,e),w){Y+=3,W-=3,U=E,B=V;const t=m[1];for(g=0;g<J;g++)U=a.Cartesian3.fromArray(t,3*(v-g-1),U),B=a.Cartesian3.fromArray(t,3*g,B),s.CorridorGeometryLibrary.addAttribute(N,U,void 0,W),s.CorridorGeometryLibrary.addAttribute(N,B,Y),D(k,q,j,Y,W,e),z=Y/3,R=z-1,H=(W-2)/3,S=H+1,K[Q++]=S,K[Q++]=R,K[Q++]=H,K[Q++]=H,K[Q++]=R,K[Q++]=z,Y+=3,W-=3}if(p.position=new d.GeometryAttribute({componentDatatype:o.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:N}),e.st){const t=new Float32Array(x/3*2);let e,r,a=0;if(w){b/=3,A/=3;const i=Math.PI/(v+1);let n;r=1/(b-v+1),e=1/(A-v+1);const s=v/2;for(g=s+1;g<v+1;g++)n=o.CesiumMath.PI_OVER_TWO+i*g,t[a++]=e*(1+Math.cos(n)),t[a++]=.5*(1+Math.sin(n));for(g=1;g<A-v+1;g++)t[a++]=g*e,t[a++]=0;for(g=v;g>s;g--)n=o.CesiumMath.PI_OVER_TWO-g*i,t[a++]=1-e*(1+Math.cos(n)),t[a++]=.5*(1+Math.sin(n));for(g=s;g>0;g--)n=o.CesiumMath.PI_OVER_TWO-i*g,t[a++]=1-r*(1+Math.cos(n)),t[a++]=.5*(1+Math.sin(n));for(g=b-v;g>0;g--)t[a++]=g*r,t[a++]=1;for(g=1;g<s+1;g++)n=o.CesiumMath.PI_OVER_TWO+i*g,t[a++]=r*(1+Math.cos(n)),t[a++]=.5*(1+Math.sin(n))}else{for(b/=3,A/=3,r=1/(b-1),e=1/(A-1),g=0;g<A;g++)t[a++]=g*e,t[a++]=0;for(g=b;g>0;g--)t[a++]=(g-1)*r,t[a++]=1}p.st=new d.GeometryAttribute({componentDatatype:o.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:t})}return e.normal&&(p.normal=new d.GeometryAttribute({componentDatatype:o.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:k.normals})),e.tangent&&(p.tangent=new d.GeometryAttribute({componentDatatype:o.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:k.tangents})),e.bitangent&&(p.bitangent=new d.GeometryAttribute({componentDatatype:o.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:k.bitangents})),{attributes:p,indices:K}}function O(t,e){if(!e.normal&&!e.tangent&&!e.bitangent&&!e.st)return t;const r=t.position.values;let i,o;(e.normal||e.bitangent)&&(i=t.normal.values,o=t.bitangent.values);const n=t.position.values.length/18,l=3*n,d=2*n,u=2*l;let c;if(e.normal||e.bitangent||e.tangent){const n=e.normal?new Float32Array(6*l):void 0,d=e.tangent?new Float32Array(6*l):void 0,m=e.bitangent?new Float32Array(6*l):void 0;let f=T,y=G,p=E,h=V,g=x,C=F,b=u;for(c=0;c<l;c+=3){const t=b+u;f=a.Cartesian3.fromArray(r,c,f),y=a.Cartesian3.fromArray(r,c+l,y),p=a.Cartesian3.fromArray(r,(c+3)%l,p),y=a.Cartesian3.subtract(y,f,y),p=a.Cartesian3.subtract(p,f,p),h=a.Cartesian3.normalize(a.Cartesian3.cross(y,p,h),h),e.normal&&(s.CorridorGeometryLibrary.addAttribute(n,h,t),s.CorridorGeometryLibrary.addAttribute(n,h,t+3),s.CorridorGeometryLibrary.addAttribute(n,h,b),s.CorridorGeometryLibrary.addAttribute(n,h,b+3)),(e.tangent||e.bitangent)&&(C=a.Cartesian3.fromArray(i,c,C),e.bitangent&&(s.CorridorGeometryLibrary.addAttribute(m,C,t),s.CorridorGeometryLibrary.addAttribute(m,C,t+3),s.CorridorGeometryLibrary.addAttribute(m,C,b),s.CorridorGeometryLibrary.addAttribute(m,C,b+3)),e.tangent&&(g=a.Cartesian3.normalize(a.Cartesian3.cross(C,h,g),g),s.CorridorGeometryLibrary.addAttribute(d,g,t),s.CorridorGeometryLibrary.addAttribute(d,g,t+3),s.CorridorGeometryLibrary.addAttribute(d,g,b),s.CorridorGeometryLibrary.addAttribute(d,g,b+3))),b+=6}if(e.normal){for(n.set(i),c=0;c<l;c+=3)n[c+l]=-i[c],n[c+l+1]=-i[c+1],n[c+l+2]=-i[c+2];t.normal.values=n}else t.normal=void 0;if(e.bitangent?(m.set(o),m.set(o,l),t.bitangent.values=m):t.bitangent=void 0,e.tangent){const e=t.tangent.values;d.set(e),d.set(e,l),t.tangent.values=d}}if(e.st){const e=t.st.values,r=new Float32Array(6*d);r.set(e),r.set(e,d);let a=2*d;for(let t=0;t<2;t++){for(r[a++]=e[0],r[a++]=e[1],c=2;c<d;c+=2){const t=e[c],i=e[c+1];r[a++]=t,r[a++]=i,r[a++]=t,r[a++]=i}r[a++]=e[0],r[a++]=e[1]}t.st.values=r}return t}function I(t,e,r){r[e++]=t[0],r[e++]=t[1],r[e++]=t[2];for(let a=3;a<t.length;a+=3){const i=t[a],o=t[a+1],n=t[a+2];r[e++]=i,r[e++]=o,r[e++]=n,r[e++]=i,r[e++]=o,r[e++]=n}return r[e++]=t[0],r[e++]=t[1],r[e++]=t[2],r}function k(e,r){const a=new f.VertexFormat({position:r.position,normal:r.normal||r.bitangent||e.shadowVolume,tangent:r.tangent,bitangent:r.normal||r.bitangent,st:r.st}),i=e.ellipsoid,n=s.CorridorGeometryLibrary.computePositions(e),u=M(n,a,i),y=e.height,p=e.extrudedHeight;let h=u.attributes;const g=u.indices;let C=h.position.values,b=C.length;const A=new Float64Array(6*b);let _=new Float64Array(b);_.set(C);let w,v=new Float64Array(4*b);C=m.PolygonPipeline.scaleToGeodeticHeight(C,y,i),v=I(C,0,v),_=m.PolygonPipeline.scaleToGeodeticHeight(_,p,i),v=I(_,2*b,v),A.set(C),A.set(_,b),A.set(v,2*b),h.position.values=A,h=O(h,r);const T=b/3;if(e.shadowVolume){const t=h.normal.values;b=t.length;let e=new Float32Array(6*b);for(w=0;w<b;w++)t[w]=-t[w];e.set(t,b),e=I(t,4*b,e),h.extrudeDirection=new d.GeometryAttribute({componentDatatype:o.ComponentDatatype.FLOAT,componentsPerAttribute:3,values:e}),r.normal||(h.normal=void 0)}if(l.defined(e.offsetAttribute)){let r=new Uint8Array(6*T);if(e.offsetAttribute===t.GeometryOffsetAttribute.TOP)r=t.arrayFill(r,1,0,T),r=t.arrayFill(r,1,2*T,4*T);else{const a=e.offsetAttribute===t.GeometryOffsetAttribute.NONE?0:1;r=t.arrayFill(r,a)}h.applyOffset=new d.GeometryAttribute({componentDatatype:o.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:r})}const G=g.length,E=T+T,V=c.IndexDatatype.createTypedArray(A.length/3,2*G+3*E);V.set(g);let x,F,L,P,N=G;for(w=0;w<G;w+=3){const t=g[w],e=g[w+1],r=g[w+2];V[N++]=r+T,V[N++]=e+T,V[N++]=t+T}for(w=0;w<E;w+=2)x=w+E,F=x+E,L=x+1,P=F+1,V[N++]=x,V[N++]=F,V[N++]=L,V[N++]=L,V[N++]=F,V[N++]=P;return{attributes:h,indices:V}}const S=new a.Cartesian3,R=new a.Cartesian3,H=new a.Cartographic;function z(t,e,r,i,o,n){const s=a.Cartesian3.subtract(e,t,S);a.Cartesian3.normalize(s,s);const l=r.geodeticSurfaceNormal(t,R),d=a.Cartesian3.cross(s,l,S);a.Cartesian3.multiplyByScalar(d,i,d);let u=o.latitude,c=o.longitude,m=n.latitude,f=n.longitude;a.Cartesian3.add(t,d,R),r.cartesianToCartographic(R,H);let y=H.latitude,p=H.longitude;u=Math.min(u,y),c=Math.min(c,p),m=Math.max(m,y),f=Math.max(f,p),a.Cartesian3.subtract(t,d,R),r.cartesianToCartographic(R,H),y=H.latitude,p=H.longitude,u=Math.min(u,y),c=Math.min(c,p),m=Math.max(m,y),f=Math.max(f,p),o.latitude=u,o.longitude=c,n.latitude=m,n.longitude=f}const B=new a.Cartesian3,U=new a.Cartesian3,Y=new a.Cartographic,W=new a.Cartographic;function q(t,r,i,o,s){t=N(t,r);const d=e.arrayRemoveDuplicates(t,a.Cartesian3.equalsEpsilon),u=d.length;if(u<2||i<=0)return new a.Rectangle;const c=.5*i;let m,f;if(Y.latitude=Number.POSITIVE_INFINITY,Y.longitude=Number.POSITIVE_INFINITY,W.latitude=Number.NEGATIVE_INFINITY,W.longitude=Number.NEGATIVE_INFINITY,o===n.CornerType.ROUNDED){const t=d[0];a.Cartesian3.subtract(t,d[1],B),a.Cartesian3.normalize(B,B),a.Cartesian3.multiplyByScalar(B,c,B),a.Cartesian3.add(t,B,U),r.cartesianToCartographic(U,H),m=H.latitude,f=H.longitude,Y.latitude=Math.min(Y.latitude,m),Y.longitude=Math.min(Y.longitude,f),W.latitude=Math.max(W.latitude,m),W.longitude=Math.max(W.longitude,f)}for(let e=0;e<u-1;++e)z(d[e],d[e+1],r,c,Y,W);const y=d[u-1];a.Cartesian3.subtract(y,d[u-2],B),a.Cartesian3.normalize(B,B),a.Cartesian3.multiplyByScalar(B,c,B),a.Cartesian3.add(y,B,U),z(y,U,r,c,Y,W),o===n.CornerType.ROUNDED&&(r.cartesianToCartographic(U,H),m=H.latitude,f=H.longitude,Y.latitude=Math.min(Y.latitude,m),Y.longitude=Math.min(Y.longitude,f),W.latitude=Math.max(W.latitude,m),W.longitude=Math.max(W.longitude,f));const p=l.defined(s)?s:new a.Rectangle;return p.north=W.latitude,p.south=Y.latitude,p.east=W.longitude,p.west=Y.longitude,p}function j(t){t=l.defaultValue(t,l.defaultValue.EMPTY_OBJECT);const e=t.positions,r=t.width;i.Check.defined("options.positions",e),i.Check.defined("options.width",r);const s=l.defaultValue(t.height,0),d=l.defaultValue(t.extrudedHeight,s);this._positions=e,this._ellipsoid=a.Ellipsoid.clone(l.defaultValue(t.ellipsoid,a.Ellipsoid.WGS84)),this._vertexFormat=f.VertexFormat.clone(l.defaultValue(t.vertexFormat,f.VertexFormat.DEFAULT)),this._width=r,this._height=Math.max(s,d),this._extrudedHeight=Math.min(s,d),this._cornerType=l.defaultValue(t.cornerType,n.CornerType.ROUNDED),this._granularity=l.defaultValue(t.granularity,o.CesiumMath.RADIANS_PER_DEGREE),this._shadowVolume=l.defaultValue(t.shadowVolume,!1),this._workerName="createCorridorGeometry",this._offsetAttribute=t.offsetAttribute,this._rectangle=void 0,this.packedLength=1+e.length*a.Cartesian3.packedLength+a.Ellipsoid.packedLength+f.VertexFormat.packedLength+7}j.pack=function(t,e,r){i.Check.defined("value",t),i.Check.defined("array",e),r=l.defaultValue(r,0);const o=t._positions,n=o.length;e[r++]=n;for(let i=0;i<n;++i,r+=a.Cartesian3.packedLength)a.Cartesian3.pack(o[i],e,r);return a.Ellipsoid.pack(t._ellipsoid,e,r),r+=a.Ellipsoid.packedLength,f.VertexFormat.pack(t._vertexFormat,e,r),r+=f.VertexFormat.packedLength,e[r++]=t._width,e[r++]=t._height,e[r++]=t._extrudedHeight,e[r++]=t._cornerType,e[r++]=t._granularity,e[r++]=t._shadowVolume?1:0,e[r]=l.defaultValue(t._offsetAttribute,-1),e};const J=a.Ellipsoid.clone(a.Ellipsoid.UNIT_SPHERE),K=new f.VertexFormat,Q={positions:void 0,ellipsoid:J,vertexFormat:K,width:void 0,height:void 0,extrudedHeight:void 0,cornerType:void 0,granularity:void 0,shadowVolume:void 0,offsetAttribute:void 0};function X(t,e){return l.defined(e)&&(t=j.unpack(t,e)),t._ellipsoid=a.Ellipsoid.clone(t._ellipsoid),j.createGeometry(t)}return j.unpack=function(t,e,r){i.Check.defined("array",t),e=l.defaultValue(e,0);const o=t[e++],n=new Array(o);for(let i=0;i<o;++i,e+=a.Cartesian3.packedLength)n[i]=a.Cartesian3.unpack(t,e);const s=a.Ellipsoid.unpack(t,e,J);e+=a.Ellipsoid.packedLength;const d=f.VertexFormat.unpack(t,e,K);e+=f.VertexFormat.packedLength;const u=t[e++],c=t[e++],m=t[e++],y=t[e++],p=t[e++],h=1===t[e++],g=t[e];return l.defined(r)?(r._positions=n,r._ellipsoid=a.Ellipsoid.clone(s,r._ellipsoid),r._vertexFormat=f.VertexFormat.clone(d,r._vertexFormat),r._width=u,r._height=c,r._extrudedHeight=m,r._cornerType=y,r._granularity=p,r._shadowVolume=h,r._offsetAttribute=-1===g?void 0:g,r):(Q.positions=n,Q.width=u,Q.height=c,Q.extrudedHeight=m,Q.cornerType=y,Q.granularity=p,Q.shadowVolume=h,Q.offsetAttribute=-1===g?void 0:g,new j(Q))},j.computeRectangle=function(t,e){t=l.defaultValue(t,l.defaultValue.EMPTY_OBJECT);const r=t.positions,o=t.width;i.Check.defined("options.positions",r),i.Check.defined("options.width",o);const s=l.defaultValue(t.ellipsoid,a.Ellipsoid.WGS84),d=l.defaultValue(t.cornerType,n.CornerType.ROUNDED);return q(r,s,o,d,e)},j.createGeometry=function(i){let n=i._positions;const u=i._width,c=i._ellipsoid;n=N(n,c);const f=e.arrayRemoveDuplicates(n,a.Cartesian3.equalsEpsilon);if(f.length<2||u<=0)return;const y=i._height,p=i._extrudedHeight,h=!o.CesiumMath.equalsEpsilon(y,p,0,o.CesiumMath.EPSILON2),g=i._vertexFormat,C={ellipsoid:c,positions:f,width:u,cornerType:i._cornerType,granularity:i._granularity,saveAttributes:!0};let b;if(h)C.height=y,C.extrudedHeight=p,C.shadowVolume=i._shadowVolume,C.offsetAttribute=i._offsetAttribute,b=k(C,g);else{const e=s.CorridorGeometryLibrary.computePositions(C);if(b=M(e,g,c),b.attributes.position.values=m.PolygonPipeline.scaleToGeodeticHeight(b.attributes.position.values,y,c),l.defined(i._offsetAttribute)){const e=i._offsetAttribute===t.GeometryOffsetAttribute.NONE?0:1,r=b.attributes.position.values.length,a=new Uint8Array(r/3);t.arrayFill(a,e),b.attributes.applyOffset=new d.GeometryAttribute({componentDatatype:o.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:1,values:a})}}const A=b.attributes,_=r.BoundingSphere.fromVertices(A.position.values,void 0,3);return g.position||(b.attributes.position.values=void 0),new d.Geometry({attributes:A,indices:b.indices,primitiveType:d.PrimitiveType.TRIANGLES,boundingSphere:_,offsetAttribute:i._offsetAttribute})},j.createShadowVolume=function(t,e,r){const a=t._granularity,i=t._ellipsoid,o=e(a,i),n=r(a,i);return new j({positions:t._positions,width:t._width,cornerType:t._cornerType,ellipsoid:i,granularity:a,extrudedHeight:o,height:n,vertexFormat:f.VertexFormat.POSITION_ONLY,shadowVolume:!0})},Object.defineProperties(j.prototype,{rectangle:{get:function(){return l.defined(this._rectangle)||(this._rectangle=q(this._positions,this._ellipsoid,this._width,this._cornerType)),this._rectangle}},textureCoordinateRotationPoints:{get:function(){return[0,0,0,1,1,0]}}}),X}));