define(["./defaultValue-94c3e563","./Matrix2-fc7e9822","./arrayRemoveDuplicates-06991c15","./BoundingRectangle-cbfe06ff","./Transforms-a076dbe6","./ComponentDatatype-4a60b8d6","./PolylineVolumeGeometryLibrary-759a8d46","./RuntimeError-c581ca93","./GeometryAttribute-2ecf73f6","./GeometryAttributes-7df9bef6","./IndexDatatype-db156785","./PolygonPipeline-cc031b9f","./_commonjsHelpers-3aae1032-f55dc0c4","./combine-761d9c3f","./WebGLConstants-7dccdc96","./EllipsoidTangentPlane-d2c0c530","./AxisAlignedBoundingBox-8103739f","./IntersectionTests-5deed78b","./Plane-e20fba8c","./PolylinePipeline-7608e667","./EllipsoidGeodesic-dc94f381","./EllipsoidRhumbLine-daebc75b"],(function(e,i,n,t,o,r,a,l,s,p,d,c,u,y,f,h,g,m,E,P,_,b){"use strict";function k(e,i){const n=new p.GeometryAttributes;n.position=new s.GeometryAttribute({componentDatatype:r.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:e});const t=i.length,a=n.position.values.length/3,l=e.length/3,c=l/t,u=d.IndexDatatype.createTypedArray(a,2*t*(c+1));let y,f,h=0;y=0;let g=y*t;for(f=0;f<t-1;f++)u[h++]=f+g,u[h++]=f+g+1;for(u[h++]=t-1+g,u[h++]=g,y=c-1,g=y*t,f=0;f<t-1;f++)u[h++]=f+g,u[h++]=f+g+1;for(u[h++]=t-1+g,u[h++]=g,y=0;y<c-1;y++){const e=t*y,i=e+t;for(f=0;f<t;f++)u[h++]=f+e,u[h++]=f+i}const m=new s.Geometry({attributes:n,indices:d.IndexDatatype.createTypedArray(a,u),boundingSphere:o.BoundingSphere.fromVertices(e),primitiveType:s.PrimitiveType.LINES});return m}function D(n){n=e.defaultValue(n,e.defaultValue.EMPTY_OBJECT);const t=n.polylinePositions,o=n.shapePositions;if(!e.defined(t))throw new l.DeveloperError("options.polylinePositions is required.");if(!e.defined(o))throw new l.DeveloperError("options.shapePositions is required.");this._positions=t,this._shape=o,this._ellipsoid=i.Ellipsoid.clone(e.defaultValue(n.ellipsoid,i.Ellipsoid.WGS84)),this._cornerType=e.defaultValue(n.cornerType,a.CornerType.ROUNDED),this._granularity=e.defaultValue(n.granularity,r.CesiumMath.RADIANS_PER_DEGREE),this._workerName="createPolylineVolumeOutlineGeometry";let s=1+t.length*i.Cartesian3.packedLength;s+=1+o.length*i.Cartesian2.packedLength,this.packedLength=s+i.Ellipsoid.packedLength+2}D.pack=function(n,t,o){if(!e.defined(n))throw new l.DeveloperError("value is required");if(!e.defined(t))throw new l.DeveloperError("array is required");let r;o=e.defaultValue(o,0);const a=n._positions;let s=a.length;for(t[o++]=s,r=0;r<s;++r,o+=i.Cartesian3.packedLength)i.Cartesian3.pack(a[r],t,o);const p=n._shape;for(s=p.length,t[o++]=s,r=0;r<s;++r,o+=i.Cartesian2.packedLength)i.Cartesian2.pack(p[r],t,o);return i.Ellipsoid.pack(n._ellipsoid,t,o),o+=i.Ellipsoid.packedLength,t[o++]=n._cornerType,t[o]=n._granularity,t};const v=i.Ellipsoid.clone(i.Ellipsoid.UNIT_SPHERE),C={polylinePositions:void 0,shapePositions:void 0,ellipsoid:v,height:void 0,cornerType:void 0,granularity:void 0};D.unpack=function(n,t,o){if(!e.defined(n))throw new l.DeveloperError("array is required");let r;t=e.defaultValue(t,0);let a=n[t++];const s=new Array(a);for(r=0;r<a;++r,t+=i.Cartesian3.packedLength)s[r]=i.Cartesian3.unpack(n,t);a=n[t++];const p=new Array(a);for(r=0;r<a;++r,t+=i.Cartesian2.packedLength)p[r]=i.Cartesian2.unpack(n,t);const d=i.Ellipsoid.unpack(n,t,v);t+=i.Ellipsoid.packedLength;const c=n[t++],u=n[t];return e.defined(o)?(o._positions=s,o._shape=p,o._ellipsoid=i.Ellipsoid.clone(d,o._ellipsoid),o._cornerType=c,o._granularity=u,o):(C.polylinePositions=s,C.shapePositions=p,C.cornerType=c,C.granularity=u,new D(C))};const w=new t.BoundingRectangle;function L(n,t){return e.defined(t)&&(n=D.unpack(n,t)),n._ellipsoid=i.Ellipsoid.clone(n._ellipsoid),D.createGeometry(n)}return D.createGeometry=function(e){const o=e._positions,r=n.arrayRemoveDuplicates(o,i.Cartesian3.equalsEpsilon);let l=e._shape;if(l=a.PolylineVolumeGeometryLibrary.removeDuplicatesFromShape(l),r.length<2||l.length<3)return;c.PolygonPipeline.computeWindingOrder2D(l)===c.WindingOrder.CLOCKWISE&&l.reverse();const s=t.BoundingRectangle.fromPoints(l,w),p=a.PolylineVolumeGeometryLibrary.computePositions(r,l,s,e,!1);return k(p,l)},L}));