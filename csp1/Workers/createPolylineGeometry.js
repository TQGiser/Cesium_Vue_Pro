define(["./defaultValue-94c3e563","./Matrix2-fc7e9822","./ArcType-0cf52f8c","./arrayRemoveDuplicates-06991c15","./Transforms-a076dbe6","./Color-ec9112c4","./ComponentDatatype-4a60b8d6","./RuntimeError-c581ca93","./GeometryAttribute-2ecf73f6","./GeometryAttributes-7df9bef6","./IndexDatatype-db156785","./PolylinePipeline-7608e667","./VertexFormat-e46f29d6","./_commonjsHelpers-3aae1032-f55dc0c4","./combine-761d9c3f","./WebGLConstants-7dccdc96","./EllipsoidGeodesic-dc94f381","./EllipsoidRhumbLine-daebc75b","./IntersectionTests-5deed78b","./Plane-e20fba8c"],(function(e,t,o,r,n,i,a,l,s,c,p,d,u,f,y,m,h,C,g,w){"use strict";const E=[];function _(e,t,o,r,n){const a=E;let l;a.length=n;const s=o.red,c=o.green,p=o.blue,d=o.alpha,u=r.red,f=r.green,y=r.blue,m=r.alpha;if(i.Color.equals(o,r)){for(l=0;l<n;l++)a[l]=i.Color.clone(o);return a}const h=(u-s)/n,C=(f-c)/n,g=(y-p)/n,w=(m-d)/n;for(l=0;l<n;l++)a[l]=new i.Color(s+l*h,c+l*C,p+l*g,d+l*w);return a}function A(r){r=e.defaultValue(r,e.defaultValue.EMPTY_OBJECT);const n=r.positions,s=r.colors,c=e.defaultValue(r.width,1),p=e.defaultValue(r.colorsPerVertex,!1);if(!e.defined(n)||n.length<2)throw new l.DeveloperError("At least two positions are required.");if("number"!==typeof c)throw new l.DeveloperError("width must be a number");if(e.defined(s)&&(p&&s.length<n.length||!p&&s.length<n.length-1))throw new l.DeveloperError("colors has an invalid length.");this._positions=n,this._colors=s,this._width=c,this._colorsPerVertex=p,this._vertexFormat=u.VertexFormat.clone(e.defaultValue(r.vertexFormat,u.VertexFormat.DEFAULT)),this._arcType=e.defaultValue(r.arcType,o.ArcType.GEODESIC),this._granularity=e.defaultValue(r.granularity,a.CesiumMath.RADIANS_PER_DEGREE),this._ellipsoid=t.Ellipsoid.clone(e.defaultValue(r.ellipsoid,t.Ellipsoid.WGS84)),this._workerName="createPolylineGeometry";let d=1+n.length*t.Cartesian3.packedLength;d+=e.defined(s)?1+s.length*i.Color.packedLength:1,this.packedLength=d+t.Ellipsoid.packedLength+u.VertexFormat.packedLength+4}A.pack=function(o,r,n){if(!e.defined(o))throw new l.DeveloperError("value is required");if(!e.defined(r))throw new l.DeveloperError("array is required");let a;n=e.defaultValue(n,0);const s=o._positions;let c=s.length;for(r[n++]=c,a=0;a<c;++a,n+=t.Cartesian3.packedLength)t.Cartesian3.pack(s[a],r,n);const p=o._colors;for(c=e.defined(p)?p.length:0,r[n++]=c,a=0;a<c;++a,n+=i.Color.packedLength)i.Color.pack(p[a],r,n);return t.Ellipsoid.pack(o._ellipsoid,r,n),n+=t.Ellipsoid.packedLength,u.VertexFormat.pack(o._vertexFormat,r,n),n+=u.VertexFormat.packedLength,r[n++]=o._width,r[n++]=o._colorsPerVertex?1:0,r[n++]=o._arcType,r[n]=o._granularity,r};const b=t.Ellipsoid.clone(t.Ellipsoid.UNIT_SPHERE),P=new u.VertexFormat,v={positions:void 0,colors:void 0,ellipsoid:b,vertexFormat:P,width:void 0,colorsPerVertex:void 0,arcType:void 0,granularity:void 0};A.unpack=function(o,r,n){if(!e.defined(o))throw new l.DeveloperError("array is required");let a;r=e.defaultValue(r,0);let s=o[r++];const c=new Array(s);for(a=0;a<s;++a,r+=t.Cartesian3.packedLength)c[a]=t.Cartesian3.unpack(o,r);s=o[r++];const p=s>0?new Array(s):void 0;for(a=0;a<s;++a,r+=i.Color.packedLength)p[a]=i.Color.unpack(o,r);const d=t.Ellipsoid.unpack(o,r,b);r+=t.Ellipsoid.packedLength;const f=u.VertexFormat.unpack(o,r,P);r+=u.VertexFormat.packedLength;const y=o[r++],m=1===o[r++],h=o[r++],C=o[r];return e.defined(n)?(n._positions=c,n._colors=p,n._ellipsoid=t.Ellipsoid.clone(d,n._ellipsoid),n._vertexFormat=u.VertexFormat.clone(f,n._vertexFormat),n._width=y,n._colorsPerVertex=m,n._arcType=h,n._granularity=C,n):(v.positions=c,v.colors=p,v.width=y,v.colorsPerVertex=m,v.arcType=h,v.granularity=C,new A(v))};const D=new t.Cartesian3,x=new t.Cartesian3,T=new t.Cartesian3,k=new t.Cartesian3;function V(o,r){return e.defined(r)&&(o=A.unpack(o,r)),o._ellipsoid=t.Ellipsoid.clone(o._ellipsoid),A.createGeometry(o)}return A.createGeometry=function(l){const u=l._width,f=l._vertexFormat;let y=l._colors;const m=l._colorsPerVertex,h=l._arcType,C=l._granularity,g=l._ellipsoid;let w,A,b;const P=[];let v=r.arrayRemoveDuplicates(l._positions,t.Cartesian3.equalsEpsilon,!1,P);if(e.defined(y)&&P.length>0){let e=0,t=P[0];y=y.filter((function(o,r){let n=!1;return n=m?r===t||0===r&&1===t:r+1===t,!n||(e++,t=P[e],!1)}))}let V=v.length;if(V<2||u<=0)return;if(h===o.ArcType.GEODESIC||h===o.ArcType.RHUMB){let t,r;h===o.ArcType.GEODESIC?(t=a.CesiumMath.chordLength(C,g.maximumRadius),r=d.PolylinePipeline.numberOfPoints):(t=C,r=d.PolylinePipeline.numberOfPointsRhumbLine);const n=d.PolylinePipeline.extractHeights(v,g);if(e.defined(y)){let e=1;for(w=0;w<V-1;++w)e+=r(v[w],v[w+1],t);const o=new Array(e);let n=0;for(w=0;w<V-1;++w){const a=v[w],l=v[w+1],s=y[w],c=r(a,l,t);if(m&&w<e){const e=y[w+1],t=_(a,l,s,e,c),r=t.length;for(A=0;A<r;++A)o[n++]=t[A]}else for(A=0;A<c;++A)o[n++]=i.Color.clone(s)}o[n]=i.Color.clone(y[y.length-1]),y=o,E.length=0}v=h===o.ArcType.GEODESIC?d.PolylinePipeline.generateCartesianArc({positions:v,minDistance:t,ellipsoid:g,height:n}):d.PolylinePipeline.generateCartesianRhumbArc({positions:v,granularity:t,ellipsoid:g,height:n})}V=v.length;const L=4*V-4,F=new Float64Array(3*L),G=new Float64Array(3*L),O=new Float64Array(3*L),R=new Float32Array(2*L),I=f.st?new Float32Array(2*L):void 0,S=e.defined(y)?new Uint8Array(4*L):void 0;let B,U=0,N=0,q=0,M=0;for(A=0;A<V;++A){let o,r;0===A?(B=D,t.Cartesian3.subtract(v[0],v[1],B),t.Cartesian3.add(v[0],B,B)):B=v[A-1],t.Cartesian3.clone(B,T),t.Cartesian3.clone(v[A],x),A===V-1?(B=D,t.Cartesian3.subtract(v[V-1],v[V-2],B),t.Cartesian3.add(v[V-1],B,B)):B=v[A+1],t.Cartesian3.clone(B,k),e.defined(S)&&(o=0===A||m?y[A]:y[A-1],A!==V-1&&(r=y[A]));const n=0===A?2:0,a=A===V-1?2:4;for(b=n;b<a;++b){t.Cartesian3.pack(x,F,U),t.Cartesian3.pack(T,G,U),t.Cartesian3.pack(k,O,U),U+=3;const n=b-2<0?-1:1;if(R[N++]=b%2*2-1,R[N++]=n*u,f.st&&(I[q++]=A/(V-1),I[q++]=Math.max(R[N-2],0)),e.defined(S)){const e=b<2?o:r;S[M++]=i.Color.floatToByte(e.red),S[M++]=i.Color.floatToByte(e.green),S[M++]=i.Color.floatToByte(e.blue),S[M++]=i.Color.floatToByte(e.alpha)}}}const H=new c.GeometryAttributes;H.position=new s.GeometryAttribute({componentDatatype:a.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:F}),H.prevPosition=new s.GeometryAttribute({componentDatatype:a.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:G}),H.nextPosition=new s.GeometryAttribute({componentDatatype:a.ComponentDatatype.DOUBLE,componentsPerAttribute:3,values:O}),H.expandAndWidth=new s.GeometryAttribute({componentDatatype:a.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:R}),f.st&&(H.st=new s.GeometryAttribute({componentDatatype:a.ComponentDatatype.FLOAT,componentsPerAttribute:2,values:I})),e.defined(S)&&(H.color=new s.GeometryAttribute({componentDatatype:a.ComponentDatatype.UNSIGNED_BYTE,componentsPerAttribute:4,values:S,normalize:!0}));const W=p.IndexDatatype.createTypedArray(L,6*V-6);let Y=0,j=0;const z=V-1;for(A=0;A<z;++A)W[j++]=Y,W[j++]=Y+2,W[j++]=Y+1,W[j++]=Y+1,W[j++]=Y+2,W[j++]=Y+3,Y+=4;return new s.Geometry({attributes:H,indices:W,primitiveType:s.PrimitiveType.TRIANGLES,boundingSphere:n.BoundingSphere.fromPoints(v),geometryType:s.GeometryType.POLYLINES})},V}));