define(["exports","./Matrix2-fc7e9822","./EllipsoidTangentPlane-d2c0c530","./ComponentDatatype-4a60b8d6","./PolylinePipeline-7608e667","./Transforms-a076dbe6","./defaultValue-94c3e563","./RuntimeError-c581ca93"],(function(e,t,a,n,r,i,o,s){"use strict";const l={ROUNDED:0,MITERED:1,BEVELED:2};var c=Object.freeze(l);const C={};function u(e,t){if(!o.defined(e))throw new s.DeveloperError("identifier is required.");o.defined(C[e])||(C[e]=!0,console.warn(o.defaultValue(t,e)))}u.geometryOutlines="Entity geometry outlines are unsupported on terrain. Outlines will be disabled. To enable outlines, disable geometry terrain clamping by explicitly setting height to 0.",u.geometryZIndex="Entity geometry with zIndex are unsupported when height or extrudedHeight are defined.  zIndex will be ignored",u.geometryHeightReference="Entity corridor, ellipse, polygon or rectangle with heightReference must also have a defined height.  heightReference will be ignored",u.geometryExtrudedHeightReference="Entity corridor, ellipse, polygon or rectangle with extrudedHeightReference must also have a defined extrudedHeight.  extrudedHeightReference will be ignored";const d=[new t.Cartesian3,new t.Cartesian3],g=new t.Cartesian3,y=new t.Cartesian3,f=new t.Cartesian3,m=new t.Cartesian3,h=new t.Cartesian3,p=new t.Cartesian3,w=new t.Cartesian3,x=new t.Cartesian3,E=new t.Cartesian3,P=new t.Cartesian3,M=new t.Cartesian3,b={};let T=new t.Cartographic;function B(e,t){const a=new Array(e.length);for(let n=0;n<e.length;n++){const r=e[n];T=t.cartesianToCartographic(r,T),a[n]=T.height,e[n]=t.scaleToGeodeticSurface(r,r)}return a}function z(e,a,n,r){const i=e[0],o=e[1],s=t.Cartesian3.angleBetween(i,o),l=Math.ceil(s/r),c=new Array(l);let C;if(a===n){for(C=0;C<l;C++)c[C]=a;return c.push(n),c}const u=n-a,d=u/l;for(C=1;C<l;C++){const e=a+C*d;c[C]=e}return c[0]=a,c.push(n),c}const S=new t.Cartesian3,A=new t.Cartesian3;function D(e,n,r,i){const o=new a.EllipsoidTangentPlane(r,i),s=o.projectPointOntoPlane(t.Cartesian3.add(r,e,S),S),l=o.projectPointOntoPlane(t.Cartesian3.add(r,n,A),A),c=t.Cartesian2.angleBetween(s,l);return l.x*s.y-l.y*s.x>=0?-c:c}const R=new t.Cartesian3(-1,0,0);let O=new t.Matrix4;const V=new t.Matrix4;let I=new t.Matrix3;const v=t.Matrix3.IDENTITY.clone(),N=new t.Cartesian3,G=new t.Cartesian4,H=new t.Cartesian3;function L(e,a,n,r,o,s,l,c){let C=N,u=G;O=i.Transforms.eastNorthUpToFixedFrame(e,o,O),C=t.Matrix4.multiplyByPointAsVector(O,R,C),C=t.Cartesian3.normalize(C,C);const d=D(C,a,e,o);I=t.Matrix3.fromRotationZ(d,I),H.z=s,O=t.Matrix4.multiplyTransformation(O,t.Matrix4.fromRotationTranslation(I,H,V),O);const g=v;g[0]=l;for(let i=0;i<c;i++)for(let e=0;e<n.length;e+=3)u=t.Cartesian3.fromArray(n,e,u),u=t.Matrix3.multiplyByVector(g,u,u),u=t.Matrix4.multiplyByPoint(O,u,u),r.push(u.x,u.y,u.z);return r}const j=new t.Cartesian3;function q(e,a,n,r,i,o,s){for(let l=0;l<e.length;l+=3){const c=t.Cartesian3.fromArray(e,l,j);r=L(c,a,n,r,i,o[l/3],s,1)}return r}function Q(e,t){const a=e.length,n=new Array(6*a);let r=0;const i=t.x+t.width/2,o=t.y+t.height/2;let s=e[0];n[r++]=s.x-i,n[r++]=0,n[r++]=s.y-o;for(let l=1;l<a;l++){s=e[l];const t=s.x-i,a=s.y-o;n[r++]=t,n[r++]=0,n[r++]=a,n[r++]=t,n[r++]=0,n[r++]=a}return s=e[0],n[r++]=s.x-i,n[r++]=0,n[r++]=s.y-o,n}function F(e,t){const a=e.length,n=new Array(3*a);let r=0;const i=t.x+t.width/2,o=t.y+t.height/2;for(let s=0;s<a;s++)n[r++]=e[s].x-i,n[r++]=0,n[r++]=e[s].y-o;return n}const U=new i.Quaternion,_=new t.Cartesian3,Z=new t.Matrix3;function W(e,a,r,o,s,l,C,u,d,g){const y=t.Cartesian3.angleBetween(t.Cartesian3.subtract(a,e,P),t.Cartesian3.subtract(r,e,M)),f=o===c.BEVELED?0:Math.ceil(y/n.CesiumMath.toRadians(5));let m,h,p;if(m=s?t.Matrix3.fromQuaternion(i.Quaternion.fromAxisAngle(t.Cartesian3.negate(e,P),y/(f+1),U),Z):t.Matrix3.fromQuaternion(i.Quaternion.fromAxisAngle(e,y/(f+1),U),Z),a=t.Cartesian3.clone(a,_),f>0){const n=g?2:1;for(let r=0;r<f;r++)a=t.Matrix3.multiplyByVector(m,a,a),h=t.Cartesian3.subtract(a,e,P),h=t.Cartesian3.normalize(h,h),s||(h=t.Cartesian3.negate(h,h)),p=l.scaleToGeodeticSurface(a,M),C=L(p,h,u,C,l,d,1,n)}else h=t.Cartesian3.subtract(a,e,P),h=t.Cartesian3.normalize(h,h),s||(h=t.Cartesian3.negate(h,h)),p=l.scaleToGeodeticSurface(a,M),C=L(p,h,u,C,l,d,1,1),r=t.Cartesian3.clone(r,_),h=t.Cartesian3.subtract(r,e,P),h=t.Cartesian3.normalize(h,h),s||(h=t.Cartesian3.negate(h,h)),p=l.scaleToGeodeticSurface(r,M),C=L(p,h,u,C,l,d,1,1);return C}b.removeDuplicatesFromShape=function(e){const a=e.length,n=[];for(let r=a-1,i=0;i<a;r=i++){const a=e[r],o=e[i];t.Cartesian2.equals(a,o)||n.push(o)}return n},b.angleIsGreaterThanPi=function(e,n,r,i){const o=new a.EllipsoidTangentPlane(r,i),s=o.projectPointOntoPlane(t.Cartesian3.add(r,e,S),S),l=o.projectPointOntoPlane(t.Cartesian3.add(r,n,A),A);return l.x*s.y-l.y*s.x>=0};const Y=new t.Cartesian3,k=new t.Cartesian3;b.computePositions=function(e,a,i,o,s){const l=o._ellipsoid,C=B(e,l),M=o._granularity,T=o._cornerType,S=s?Q(a,i):F(a,i),A=s?F(a,i):void 0,D=i.height/2,R=i.width/2;let O=e.length,V=[],I=s?[]:void 0,v=g,N=y,G=f,H=m,j=h,U=p,_=w,Z=x,J=E,K=e[0],X=e[1];H=l.geodeticSurfaceNormal(K,H),v=t.Cartesian3.subtract(X,K,v),v=t.Cartesian3.normalize(v,v),Z=t.Cartesian3.cross(H,v,Z),Z=t.Cartesian3.normalize(Z,Z);let $,ee,te=C[0],ae=C[1];s&&(I=L(K,Z,A,I,l,te+D,1,1)),J=t.Cartesian3.clone(K,J),K=X,N=t.Cartesian3.negate(v,N);for(let g=1;g<O-1;g++){const a=s?2:1;if(X=e[g+1],K.equals(X)){u("Positions are too close and are considered equivalent with rounding error.");continue}v=t.Cartesian3.subtract(X,K,v),v=t.Cartesian3.normalize(v,v),G=t.Cartesian3.add(v,N,G),G=t.Cartesian3.normalize(G,G),H=l.geodeticSurfaceNormal(K,H);const i=t.Cartesian3.multiplyByScalar(H,t.Cartesian3.dot(v,H),Y);t.Cartesian3.subtract(v,i,i),t.Cartesian3.normalize(i,i);const o=t.Cartesian3.multiplyByScalar(H,t.Cartesian3.dot(N,H),k);t.Cartesian3.subtract(N,o,o),t.Cartesian3.normalize(o,o);const y=!n.CesiumMath.equalsEpsilon(Math.abs(t.Cartesian3.dot(i,o)),1,n.CesiumMath.EPSILON7);if(y){G=t.Cartesian3.cross(G,H,G),G=t.Cartesian3.cross(H,G,G),G=t.Cartesian3.normalize(G,G);const e=1/Math.max(.25,t.Cartesian3.magnitude(t.Cartesian3.cross(G,N,P))),n=b.angleIsGreaterThanPi(v,N,K,l);n?(j=t.Cartesian3.add(K,t.Cartesian3.multiplyByScalar(G,e*R,G),j),U=t.Cartesian3.add(j,t.Cartesian3.multiplyByScalar(Z,R,U),U),d[0]=t.Cartesian3.clone(J,d[0]),d[1]=t.Cartesian3.clone(U,d[1]),$=z(d,te+D,ae+D,M),ee=r.PolylinePipeline.generateArc({positions:d,granularity:M,ellipsoid:l}),V=q(ee,Z,S,V,l,$,1),Z=t.Cartesian3.cross(H,v,Z),Z=t.Cartesian3.normalize(Z,Z),_=t.Cartesian3.add(j,t.Cartesian3.multiplyByScalar(Z,R,_),_),T===c.ROUNDED||T===c.BEVELED?W(j,U,_,T,n,l,V,S,ae+D,s):(G=t.Cartesian3.negate(G,G),V=L(K,G,S,V,l,ae+D,e,a)),J=t.Cartesian3.clone(_,J)):(j=t.Cartesian3.add(K,t.Cartesian3.multiplyByScalar(G,e*R,G),j),U=t.Cartesian3.add(j,t.Cartesian3.multiplyByScalar(Z,-R,U),U),d[0]=t.Cartesian3.clone(J,d[0]),d[1]=t.Cartesian3.clone(U,d[1]),$=z(d,te+D,ae+D,M),ee=r.PolylinePipeline.generateArc({positions:d,granularity:M,ellipsoid:l}),V=q(ee,Z,S,V,l,$,1),Z=t.Cartesian3.cross(H,v,Z),Z=t.Cartesian3.normalize(Z,Z),_=t.Cartesian3.add(j,t.Cartesian3.multiplyByScalar(Z,-R,_),_),T===c.ROUNDED||T===c.BEVELED?W(j,U,_,T,n,l,V,S,ae+D,s):V=L(K,G,S,V,l,ae+D,e,a),J=t.Cartesian3.clone(_,J)),N=t.Cartesian3.negate(v,N)}else V=L(J,Z,S,V,l,te+D,1,1),J=K;te=ae,ae=C[g+1],K=X}d[0]=t.Cartesian3.clone(J,d[0]),d[1]=t.Cartesian3.clone(K,d[1]),$=z(d,te+D,ae+D,M),ee=r.PolylinePipeline.generateArc({positions:d,granularity:M,ellipsoid:l}),V=q(ee,Z,S,V,l,$,1),s&&(I=L(K,Z,A,I,l,ae+D,1,1)),O=V.length;const ne=s?O+I.length:O,re=new Float64Array(ne);return re.set(V),s&&re.set(I,O),re},e.CornerType=c,e.PolylineVolumeGeometryLibrary=b,e.oneTimeWarning=u}));